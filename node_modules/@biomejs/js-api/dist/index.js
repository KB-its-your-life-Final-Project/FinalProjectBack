"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Biome = exports.Distribution = void 0;
const wasm_1 = require("./wasm");
Object.defineProperty(exports, "Distribution", { enumerable: true, get: function () { return wasm_1.Distribution; } });
function isFormatContentDebug(options) {
    return "debug" in options && options.debug !== undefined;
}
class Biome {
    constructor(module, workspace) {
        this.module = module;
        this.workspace = workspace;
    }
    /**
     * It creates a new instance of the class {Biome}.
     */
    static async create(options) {
        const module = await (0, wasm_1.loadModule)(options.distribution);
        const workspace = new module.Workspace();
        const biome = new Biome(module, workspace);
        biome.openProject();
        return biome;
    }
    /**
     * Stop this instance of Biome
     *
     * After calling `shutdown()` on this object, it should be considered
     * unusable as calling any method on it will fail
     */
    shutdown() {
        this.workspace.free();
    }
    /**
     * Allows to apply a custom configuration.
     *
     * If fails when the configuration is incorrect.
     *
     * @param {ProjectKey} projectKey The identifier of the project
     * @param {Configuration} configuration
     */
    applyConfiguration(projectKey, configuration) {
        try {
            this.workspace.updateSettings({
                projectKey,
                configuration,
                workspaceDirectory: "./",
            });
        }
        catch (e) {
            throw (0, wasm_1.wrapError)(e);
        }
    }
    /**
     * Open a possible workspace project folder. Returns the key of said project. Use this key when you want to switch to different projects.
     *
     * @param {string} [path]
     */
    openProject(path) {
        return this.workspace.openProject({
            path: path || "",
            openUninitialized: true,
        });
    }
    tryCatchWrapper(func) {
        try {
            return func();
        }
        catch (err) {
            throw (0, wasm_1.wrapError)(err);
        }
    }
    withFile(projectKey, path, content, func) {
        return this.tryCatchWrapper(() => {
            this.workspace.openFile({
                projectKey,
                content: { type: "fromClient", content, version: 0 },
                path,
            });
            try {
                return func(path);
            }
            finally {
                this.workspace.closeFile({
                    projectKey,
                    path,
                });
            }
        });
    }
    /**
     * If formats some content.
     *
     * @param {ProjectKey} projectKey The identifier of the project
     * @param {String} content The content to format
     * @param {FormatContentOptions | FormatContentDebugOptions} options Options needed when formatting some content
     */
    formatContent(projectKey, content, options) {
        return this.withFile(projectKey, options.filePath, content, (path) => {
            let code = content;
            const { diagnostics } = this.workspace.pullDiagnostics({
                projectKey,
                path,
                categories: ["syntax"],
                only: [],
                skip: [],
                pullCodeActions: false,
            });
            const hasErrors = diagnostics.some((diag) => diag.severity === "fatal" || diag.severity === "error");
            if (!hasErrors) {
                if (options.range) {
                    const result = this.workspace.formatRange({
                        projectKey,
                        path,
                        range: options.range,
                    });
                    code = result.code;
                }
                else {
                    const result = this.workspace.formatFile({
                        projectKey,
                        path,
                    });
                    code = result.code;
                }
                if (isFormatContentDebug(options)) {
                    const ir = this.workspace.getFormatterIr({
                        projectKey,
                        path,
                    });
                    return {
                        content: code,
                        diagnostics,
                        ir,
                    };
                }
            }
            return {
                content: code,
                diagnostics,
            };
        });
    }
    /**
     * Lint the content of a file.
     *
     * @param {ProjectKey} projectKey The identifier of the project
     * @param {String} content The content to lint
     * @param {LintContentOptions} options Options needed when linting some content
     */
    lintContent(projectKey, content, { filePath, fixFileMode }) {
        const maybeFixedContent = fixFileMode
            ? this.withFile(projectKey, filePath, content, (path) => {
                let code = content;
                const result = this.workspace.fixFile({
                    projectKey,
                    path,
                    fixFileMode: fixFileMode,
                    shouldFormat: false,
                    only: [],
                    skip: [],
                    ruleCategories: ["syntax", "lint", "action"],
                });
                code = result.code;
                return code;
            })
            : content;
        return this.withFile(projectKey, filePath, maybeFixedContent, (path) => {
            const { diagnostics } = this.workspace.pullDiagnostics({
                projectKey,
                path,
                categories: ["syntax", "lint", "action"],
                only: [],
                skip: [],
                pullCodeActions: false,
            });
            return {
                content: maybeFixedContent,
                diagnostics,
            };
        });
    }
    /**
     * Print a list of diagnostics to an HTML string.
     *
     * @param {Diagnostic[]} diagnostics The list of diagnostics to print
     * @param {PrintDiagnosticsOptions} options Options needed for printing the diagnostics
     */
    printDiagnostics(diagnostics, options) {
        return this.tryCatchWrapper(() => {
            const printer = new this.module.DiagnosticPrinter(options.filePath, options.fileSource);
            try {
                for (const diag of diagnostics) {
                    if (options.verbose) {
                        printer.print_verbose(diag);
                    }
                    else {
                        printer.print_simple(diag);
                    }
                }
                return printer.finish();
            }
            catch (err) {
                // Only call `free` if the `print` method throws, `finish` will
                // take care of deallocating the printer even if it fails
                printer.free();
                throw err;
            }
        });
    }
}
exports.Biome = Biome;
//# sourceMappingURL=index.js.map