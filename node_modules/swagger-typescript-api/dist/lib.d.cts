import { OpenAPI } from "openapi-types";
import * as typescript$1 from "typescript";
import * as typescript from "typescript";
import * as lodash19 from "lodash";
import * as lodash14 from "lodash";
import lodash from "lodash";
import * as swagger_schema_official16 from "swagger-schema-official";
import * as eta20 from "eta";

//#region rolldown:runtime
//#endregion
//#region src/schema-components-map.d.ts
declare class SchemaComponentsMap {
  _data: SchemaComponent[];
  config: CodeGenConfig;
  constructor(config: CodeGenConfig);
  clear(): void;
  createRef: (paths: string[]) => string;
  parseRef: (ref: string) => string[];
  createComponent($ref: string, rawTypeData: SchemaComponent["rawTypeData"]): SchemaComponent;
  getComponents(): SchemaComponent[];
  filter(...componentNames: (string[] | string)[]): SchemaComponent[];
  get($ref: string): SchemaComponent | null;
  enumsFirst(): void;
}
//#endregion
//#region src/util/file-system.d.ts
declare class FileSystem {
  getFileContent: (path: string) => string;
  readDir: (path: string) => string[];
  pathIsDir: (path: string) => boolean;
  cropExtension: (fileName: string) => string;
  removeDir: (path: string) => void;
  createDir: (path: string) => void;
  cleanDir: (path: string) => void;
  pathIsExist: (path: string) => boolean;
  createFile: ({
    path: path_,
    fileName,
    content,
    withPrefix
  }: {
    path: any;
    fileName: any;
    content: any;
    withPrefix: any;
  }) => void;
}
//#endregion
//#region src/util/request.d.ts
declare class Request {
  config: CodeGenConfig;
  constructor(config: CodeGenConfig);
  download({
    url,
    authToken,
    ...options
  }: {
    url: string;
    authToken?: string;
    options?: Partial<RequestInit>;
  }): Promise<string>;
}
//#endregion
//#region src/swagger-schema-resolver.d.ts
declare class SwaggerSchemaResolver {
  config: CodeGenConfig;
  fileSystem: FileSystem;
  request: Request;
  constructor(config: CodeGenConfig, fileSystem: FileSystem);
  create(): Promise<{
    usageSchema: OpenAPI.Document;
    originalSchema: OpenAPI.Document;
  }>;
  convertSwaggerObject(swaggerSchema: OpenAPI.Document, converterOptions: {
    patch?: boolean;
  }): Promise<{
    usageSchema: OpenAPI.Document;
    originalSchema: OpenAPI.Document;
  }>;
  getSwaggerSchemaByPath: (pathToSwagger: string) => string;
  fetchSwaggerSchemaFile(pathToSwagger: string, urlToSwagger: string, authToken?: string): Promise<string>;
  processSwaggerSchemaFile(file: string): any;
  fixSwaggerSchema({
    usageSchema,
    originalSchema
  }: {
    usageSchema: any;
    originalSchema: any;
  }): void;
}
//#endregion
//#region src/schema-walker.d.ts
declare class SchemaWalker {
  config: CodeGenConfig;
  swaggerSchemaResolver: SwaggerSchemaResolver;
  schemas: Map<string, OpenAPI.Document<{}>>;
  caches: Map<string, OpenAPI.Document<{}>>;
  constructor(config: CodeGenConfig, swaggerSchemaResolver: SwaggerSchemaResolver);
  addSchema: (name: string, schema: OpenAPI.Document) => void;
  _isLocalRef: (ref: string) => boolean;
  _isRemoteRef: (ref: string) => boolean;
  _getRefDataFromSchema: (schema: Record<string, unknown>, ref: string) => any;
}
//#endregion
//#region src/type-name-formatter.d.ts
type FormattingSchemaType = "enum-key" | "type-name";
declare class TypeNameFormatter {
  formattedModelNamesMap: Map<string, string>;
  config: CodeGenConfig;
  constructor(config: CodeGenConfig);
  format: (name: string, options?: {
    type?: FormattingSchemaType;
  }) => string | undefined;
  isValidName: (name: string) => boolean;
  fixModelName: (name: string, options: {
    type?: FormattingSchemaType;
  }) => string;
}
//#endregion
//#region src/schema-parser/schema-utils.d.ts
declare class SchemaUtils {
  config: CodeGenConfig;
  schemaComponentsMap: SchemaComponentsMap;
  typeNameFormatter: TypeNameFormatter;
  schemaWalker: SchemaWalker;
  constructor({
    config,
    schemaComponentsMap,
    typeNameFormatter,
    schemaWalker
  }: {
    config: any;
    schemaComponentsMap: any;
    typeNameFormatter: any;
    schemaWalker: any;
  });
  getRequiredProperties: (schema: any) => unknown[];
  isRefSchema: (schema: any) => boolean;
  getEnumNames: (schema: any) => any;
  getEnumDescriptions: (schema: any) => any;
  getSchemaPropertyNamesSchema: (schema: any) => any;
  getSchemaRefType: (schema: any) => SchemaComponent | null;
  isPropertyRequired: (name: any, propertySchema: any, rootSchema: any) => any;
  isNullMissingInType: (schema: any, type: any) => any;
  safeAddNullToType: (schema: any, type: any) => any;
  getSchemaPrimitiveType: (rawSchema: any) => string | null | undefined;
  checkAndAddRequiredKeys: (schema: any, resultType: any) => any;
  makeAddRequiredToChildSchema: (parentSchema: any, childSchema: any) => any;
  filterSchemaContents: (contents: any, filterFn: any) => unknown[];
  resolveTypeName: (typeName: any, {
    suffixes,
    resolver,
    prefixes,
    shouldReserve
  }: {
    suffixes: any;
    resolver: any;
    prefixes: any;
    shouldReserve?: boolean | undefined;
  }) => string | null;
  getComplexType: (schema: any) => "oneOf" | "anyOf" | "allOf" | "not" | "__unknown";
  getInternalSchemaType: (schema: any) => "object" | "array" | "enum" | "primitive" | "complex" | "discriminator";
  getSchemaType: (schema: any) => any;
  buildTypeNameFromPath: (schemaPath: any) => Capitalize<string> | null;
  isConstantSchema(schema: any): boolean;
  formatJsValue: (value: any) => string;
}
//#endregion
//#region src/schema-parser/schema-formatters.d.ts
declare class SchemaFormatters {
  config: CodeGenConfig;
  templatesWorker: TemplatesWorker;
  schemaUtils: SchemaUtils;
  constructor(schemaParser: SchemaParser | SchemaParserFabric);
  base: {
    enum: (parsedSchema: any) => any;
    object: (parsedSchema: any) => any;
    primitive: (parsedSchema: any) => any;
  };
  inline: {
    enum: (parsedSchema: any) => any;
    object: (parsedSchema: any) => any;
  };
  formatSchema: (parsedSchema: Record<string, any>, formatType?: "base" | "inline") => any;
  formatDescription: (description: any, inline: any) => any;
  formatObjectContent: (content: any) => string;
}
//#endregion
//#region src/schema-parser/schema-parser-fabric.d.ts
declare class SchemaParserFabric {
  config: CodeGenConfig;
  schemaComponentsMap: SchemaComponentsMap;
  typeNameFormatter: TypeNameFormatter;
  schemaFormatters: SchemaFormatters;
  templatesWorker: TemplatesWorker;
  schemaUtils: SchemaUtils;
  schemaWalker: SchemaWalker;
  constructor(config: CodeGenConfig, templatesWorker: TemplatesWorker, schemaComponentsMap: SchemaComponentsMap, typeNameFormatter: TypeNameFormatter, schemaWalker: SchemaWalker);
  createSchemaParser: ({
    schema,
    typeName,
    schemaPath
  }: {
    schema: any;
    typeName: any;
    schemaPath: any;
  }) => SchemaParser;
  createSchema: ({
    content,
    linkedSchema,
    linkedComponent,
    schemaPath,
    ...otherSchemaProps
  }: {
    [x: string]: any;
    content: any;
    linkedSchema?: {} | undefined;
    linkedComponent: any;
    schemaPath: any;
  }) => any;
  createParsedComponent: ({
    typeName,
    schema,
    schemaPath
  }: {
    typeName: any;
    schema: any;
    schemaPath: any;
  }) => SchemaComponent;
  parseSchema: (schema: string, typeName?: string | null, schemaPath?: string[]) => ParsedSchema<SchemaTypeObjectContent | SchemaTypeEnumContent | SchemaTypePrimitiveContent>;
  getInlineParseContent: (schema: string, typeName: string | null, schemaPath: string[]) => Record<string, any>;
  getParseContent: (schema: string, typeName: string | null, schemaPath: string[]) => Record<string, any>;
}
//#endregion
//#region src/schema-routes/schema-routes.d.ts
declare class SchemaRoutes {
  config: CodeGenConfig;
  schemaParserFabric: SchemaParserFabric;
  schemaUtils: SchemaUtils;
  typeNameFormatter: TypeNameFormatter;
  schemaComponentsMap: SchemaComponentsMap;
  templatesWorker: TemplatesWorker;
  FORM_DATA_TYPES: string[];
  routes: ParsedRoute[];
  hasSecurityRoutes: boolean;
  hasQueryRoutes: boolean;
  hasFormDataRoutes: boolean;
  constructor(config: CodeGenConfig, schemaParserFabric: SchemaParserFabric, schemaComponentsMap: SchemaComponentsMap, templatesWorker: TemplatesWorker, typeNameFormatter: TypeNameFormatter);
  createRequestsMap: (routeInfoByMethodsMap: any) => {};
  parseRouteName: (originalRouteName: any) => {
    originalRoute: string;
    route: string;
    pathParams: {
      $match: string;
      name: string;
      required: boolean;
      type: "string";
      description: string;
      schema: {
        type: string;
      };
      in: "path" | "query";
    }[];
    queryParams: {
      $match: string;
      name: string;
      required: boolean;
      type: "string";
      description: string;
      schema: {
        type: string;
      };
      in: "path" | "query";
    }[];
  } | {
    originalRoute: any;
    route: any;
    pathParams: never[];
    queryParams: {
      $match: unknown;
      name: string;
      required: boolean;
      type: string;
      description: string;
      schema: {
        type: string;
      };
      in: string;
    }[];
  };
  getRouteParams: (routeInfo: any, pathParamsFromRouteName: any, queryParamsFromRouteName: any) => {
    path: never[];
    header: never[];
    body: never[];
    query: never[];
    formData: never[];
    cookie: never[];
  };
  getContentTypes: (requestInfo: any, extraContentTypes: any) => any[];
  getContentKind: (contentTypes: any) => string;
  isSuccessStatus: (status: any) => boolean;
  getSchemaFromRequestType: (requestInfo: any) => any;
  getTypeFromRequestInfo: ({
    requestInfo,
    parsedSchemas,
    operationId,
    defaultType,
    typeName
  }: {
    requestInfo: any;
    parsedSchemas: any;
    operationId: any;
    defaultType: any;
    typeName: any;
  }) => any;
  getRequestInfoTypes: ({
    requestInfos,
    parsedSchemas,
    operationId,
    defaultType
  }: {
    requestInfos: any;
    parsedSchemas: any;
    operationId: any;
    defaultType: any;
  }) => never[];
  getResponseBodyInfo: (routeInfo: any, parsedSchemas: any) => {
    contentTypes: any[];
    responses: never[];
    success: {
      schema: undefined;
      type: any;
    };
    error: {
      schemas: never[];
      type: string;
    };
    full: {
      types: string;
    };
  };
  convertRouteParamsIntoObject: (params: any) => any;
  getRequestBodyInfo: (routeInfo: any, routeParams: any, parsedSchemas: any, routeName: any) => any;
  createRequestParamsSchema: ({
    queryParams,
    queryObjectSchema,
    pathArgsSchemas,
    extractRequestParams,
    routeName
  }: {
    queryParams: any;
    queryObjectSchema: any;
    pathArgsSchemas: any;
    extractRequestParams: any;
    routeName: any;
  }) => any;
  extractResponseBodyIfItNeeded: (routeInfo: any, responseBodyInfo: any, routeName: any) => void;
  extractResponseErrorIfItNeeded: (routeInfo: any, responseBodyInfo: any, routeName: any) => void;
  getRouteName: (rawRouteInfo: any) => RouteNameInfo;
  parseRouteInfo: (rawRouteName: any, routeInfo: any, method: any, usageSchema: any, parsedSchemas: any) => ParsedRoute;
  attachSchema: ({
    usageSchema,
    parsedSchemas
  }: {
    usageSchema: any;
    parsedSchemas: any;
  }) => void;
  getGroupedRoutes: () => {
    outOfModule: ParsedRoute[];
    combined?: {
      moduleName: string;
      routes: ParsedRoute[];
    }[];
  };
  sortRoutes: (routes: ParsedRoute[]) => ParsedRoute[];
}
//#endregion
//#region src/translators/javascript.d.ts
declare class JavascriptTranslator extends Translator {
  compileTSCode: (input: TranslatorIO) => Record<string, string>;
  translate: (input: any) => Promise<{
    fileName: any;
    fileExtension: typescript$1.Extension;
    fileContent: string;
  }[]>;
}
//#endregion
//#region src/util/internal-case.d.ts
declare function internalCase(value: string): string;
//#endregion
//#region src/util/name-resolver.d.ts
type Resolver = (reserved: string[], extras?: string[]) => string;
declare class NameResolver {
  reservedNames: string[];
  getFallbackName: Resolver;
  config: CodeGenConfig;
  constructor(config: CodeGenConfig, reservedNames: string[], getFallbackName: Resolver);
  reserve(names: string[]): void;
  unreserve(names: string[]): void;
  isReserved(name: string): boolean;
  resolve(variants: string[], resolver?: Resolver, extras?: string[], shouldReserve?: boolean): string | null;
}
//#endregion
//#region src/util/pascal-case.d.ts
declare function pascalCase(value: string): Capitalize<string>;
//#endregion
//#region src/code-gen-process.d.ts
declare class CodeGenProcess {
  config: CodeGenConfig;
  swaggerSchemaResolver: SwaggerSchemaResolver;
  schemaComponentsMap: SchemaComponentsMap;
  typeNameFormatter: TypeNameFormatter;
  schemaParserFabric: SchemaParserFabric;
  schemaRoutes: SchemaRoutes;
  fileSystem: FileSystem;
  codeFormatter: CodeFormatter;
  templatesWorker: TemplatesWorker;
  schemaWalker: SchemaWalker;
  javascriptTranslator: JavascriptTranslator;
  constructor(config: Partial<GenerateApiConfiguration["config"]>);
  start(): Promise<{
    files: TranslatorIO[];
    configuration: GenerateApiConfiguration | {
      apiConfig: {
        info: any;
        servers: any;
        basePath: any;
        host: any;
        externalDocs: any;
        tags: unknown[];
        baseUrl: any;
        title: any;
        version: any;
      };
      config: CodeGenConfig;
      modelTypes: any[];
      hasSecurityRoutes: boolean;
      hasQueryRoutes: boolean;
      hasFormDataRoutes: boolean;
      generateResponses: boolean;
      routes: {
        outOfModule: ParsedRoute[];
        combined?: {
          moduleName: string;
          routes: ParsedRoute[];
        }[];
      };
      extraTemplates: never[];
      fileName: string;
      translateToJavaScript: boolean;
      customTranslator: Translator | null;
      utils: {
        Ts: {
          Keyword: {
            Number: string;
            String: string;
            Boolean: string;
            Any: string;
            Void: string;
            Unknown: string;
            Null: string;
            Undefined: string;
            Object: string;
            File: string;
            Date: string;
            Type: string;
            Enum: string;
            Interface: string;
            Array: string;
            Record: string;
            Intersection: string;
            Union: string;
          };
          CodeGenKeyword: {
            UtilRequiredKeys: string;
          };
          ArrayType: (content: unknown) => string;
          StringValue: (content: unknown) => string;
          BooleanValue: (content: unknown) => string;
          NumberValue: (content: unknown) => string;
          NullValue: () => string;
          UnionType: (contents: unknown[]) => string;
          ExpressionGroup: (content: unknown) => string;
          IntersectionType: (contents: unknown[]) => string;
          RecordType: (key: unknown, value: unknown) => string;
          TypeField: ({
            readonly,
            key,
            optional,
            value
          }: Record<string, unknown>) => string;
          InterfaceDynamicField: (key: unknown, value: unknown) => string;
          EnumUsageKey: (enumStruct: unknown, key: unknown) => string;
          EnumField: (key: unknown, value: unknown) => string;
          EnumFieldDescription: (description: any) => string;
          EnumFieldsWrapper: (contents: Record<string, unknown>[]) => string;
          ObjectWrapper: (content: unknown) => string;
          MultilineComment: (contents: unknown[], formatFn: (arg: unknown) => unknown) => string[];
          TypeWithGeneric: (typeName: unknown, genericArgs: unknown[]) => string;
          Tuple: (values: unknown[]) => string;
        };
        formatDescription: (description: any, inline: any) => any;
        internalCase: typeof internalCase;
        classNameCase: typeof pascalCase;
        pascalCase: typeof pascalCase;
        getInlineParseContent: (schema: string, typeName: string | null, schemaPath: string[]) => Record<string, any>;
        getParseContent: (schema: string, typeName: string | null, schemaPath: string[]) => Record<string, any>;
        getComponentByRef: ($ref: string) => SchemaComponent | null;
        parseSchema: (schema: string, typeName?: string | null, schemaPath?: string[]) => ParsedSchema<SchemaTypeObjectContent | SchemaTypeEnumContent | SchemaTypePrimitiveContent>;
        checkAndAddNull: (schema: any, type: any) => any;
        safeAddNullToType: (schema: any, type: any) => any;
        isNeedToAddNull: (schema: any, type: any) => any;
        inlineExtraFormatters: {
          enum: (parsedSchema: any) => any;
          object: (parsedSchema: any) => any;
        };
        formatters: {
          enum: (parsedSchema: any) => any;
          object: (parsedSchema: any) => any;
          primitive: (parsedSchema: any) => any;
        };
        formatModelName: (name: string, options?: {
          type?: "enum-key" | "type-name";
        }) => string | undefined;
        fmtToJSDocLine: (line: string, {
          eol
        }: {
          eol?: boolean | undefined;
        }) => string;
        NameResolver: typeof NameResolver;
        _: lodash.LoDashStatic;
        require: (packageOrPath: string) => Promise<any>;
      };
    };
    getTemplate: (name: string, fileName: string, path?: string) => string | undefined;
    renderTemplate: (template: string, configuration: object, options?: object) => string;
    createFile: ({
      path: path_,
      fileName,
      content,
      withPrefix
    }: {
      path: any;
      fileName: any;
      content: any;
      withPrefix: any;
    }) => void;
    formatTSContent: (code: string, {
      removeUnusedImports,
      format
    }?: {
      removeUnusedImports?: boolean | undefined;
      format?: boolean | undefined;
    }) => Promise<string>;
  }>;
  getRenderTemplateData: () => {
    utils: {
      Ts: {
        Keyword: {
          Number: string;
          String: string;
          Boolean: string;
          Any: string;
          Void: string;
          Unknown: string;
          Null: string;
          Undefined: string;
          Object: string;
          File: string;
          Date: string;
          Type: string;
          Enum: string;
          Interface: string;
          Array: string;
          Record: string;
          Intersection: string;
          Union: string;
        };
        CodeGenKeyword: {
          UtilRequiredKeys: string;
        };
        ArrayType: (content: unknown) => string;
        StringValue: (content: unknown) => string;
        BooleanValue: (content: unknown) => string;
        NumberValue: (content: unknown) => string;
        NullValue: () => string;
        UnionType: (contents: unknown[]) => string;
        ExpressionGroup: (content: unknown) => string;
        IntersectionType: (contents: unknown[]) => string;
        RecordType: (key: unknown, value: unknown) => string;
        TypeField: ({
          readonly,
          key,
          optional,
          value
        }: Record<string, unknown>) => string;
        InterfaceDynamicField: (key: unknown, value: unknown) => string;
        EnumUsageKey: (enumStruct: unknown, key: unknown) => string;
        EnumField: (key: unknown, value: unknown) => string;
        EnumFieldDescription: (description: any) => string;
        EnumFieldsWrapper: (contents: Record<string, unknown>[]) => string;
        ObjectWrapper: (content: unknown) => string;
        MultilineComment: (contents: unknown[], formatFn: (arg: unknown) => unknown) => string[];
        TypeWithGeneric: (typeName: unknown, genericArgs: unknown[]) => string;
        Tuple: (values: unknown[]) => string;
      };
      formatDescription: (description: any, inline: any) => any;
      internalCase: typeof internalCase;
      classNameCase: typeof pascalCase;
      pascalCase: typeof pascalCase;
      getInlineParseContent: (schema: string, typeName: string | null, schemaPath: string[]) => Record<string, any>;
      getParseContent: (schema: string, typeName: string | null, schemaPath: string[]) => Record<string, any>;
      getComponentByRef: ($ref: string) => SchemaComponent | null;
      parseSchema: (schema: string, typeName?: string | null, schemaPath?: string[]) => ParsedSchema<SchemaTypeObjectContent | SchemaTypeEnumContent | SchemaTypePrimitiveContent>;
      checkAndAddNull: (schema: any, type: any) => any;
      safeAddNullToType: (schema: any, type: any) => any;
      isNeedToAddNull: (schema: any, type: any) => any;
      inlineExtraFormatters: {
        enum: (parsedSchema: any) => any;
        object: (parsedSchema: any) => any;
      };
      formatters: {
        enum: (parsedSchema: any) => any;
        object: (parsedSchema: any) => any;
        primitive: (parsedSchema: any) => any;
      };
      formatModelName: (name: string, options?: {
        type?: "enum-key" | "type-name";
      }) => string | undefined;
      fmtToJSDocLine: (line: string, {
        eol
      }: {
        eol?: boolean | undefined;
      }) => string;
      NameResolver: typeof NameResolver;
      _: lodash.LoDashStatic;
      require: (packageOrPath: string) => Promise<any>;
    };
    config: CodeGenConfig;
  };
  collectModelTypes: () => any[];
  prepareModelType: (typeInfo: any) => any;
  generateOutputFiles: ({
    configuration
  }: {
    configuration: any;
  }) => Promise<TranslatorIO[]>;
  createMultipleFileInfos: (templatesToRender: any, configuration: any) => Promise<TranslatorIO[]>;
  createSingleFileInfo: (templatesToRender: any, configuration: any) => Promise<TranslatorIO[]>;
  createOutputFileInfo: (configuration: any, fileNameFull: any, content: any) => Promise<TranslatorIO[]>;
  createApiConfig: (swaggerSchema: any) => {
    info: any;
    servers: any;
    basePath: any;
    host: any;
    externalDocs: any;
    tags: unknown[];
    baseUrl: any;
    title: any;
    version: any;
  };
  injectClassInstance: (key: any, value: any) => void;
}
//#endregion
//#region src/templates-worker.d.ts
declare class TemplatesWorker {
  config: CodeGenConfig;
  fileSystem: FileSystem;
  getRenderTemplateData: CodeGenProcess["getRenderTemplateData"];
  constructor(config: CodeGenConfig, fileSystem: FileSystem, getRenderTemplateData: CodeGenProcess["getRenderTemplateData"]);
  getTemplatePaths: (config: CodeGenConfig) => CodeGenConfig["templatePaths"];
  cropExtension: (path: string) => string;
  getTemplateFullPath: (path_: string, fileName: string) => string | undefined;
  requireFnFromTemplate: (packageOrPath: string) => Promise<any>;
  getTemplate: (name: string, fileName: string, path?: string) => string | undefined;
  getTemplates: ({
    templatePaths
  }: CodeGenConfig) => {};
  findTemplateWithExt: (path: string) => string | undefined;
  getTemplateContent: (path_: string) => string;
  renderTemplate: (template: string, configuration: object, options?: object) => string;
}
//#endregion
//#region src/schema-parser/schema-parser.d.ts
declare class SchemaParser {
  schemaParserFabric: SchemaParserFabric;
  config: CodeGenConfig;
  schemaComponentsMap: SchemaComponentsMap;
  typeNameFormatter: TypeNameFormatter;
  schemaFormatters: SchemaFormatters;
  schemaUtils: SchemaUtils;
  templatesWorker: TemplatesWorker;
  schemaWalker: SchemaWalker;
  typeName: any;
  schema: any;
  schemaPath: never[];
  constructor(schemaParserFabric: any, {
    typeName,
    schema,
    schemaPath
  }?: {});
  _complexSchemaParsers: {
    oneOf: (schema: any) => any;
    allOf: (schema: any) => any;
    anyOf: (schema: any) => any;
    not: (schema: any) => any;
  };
  _baseSchemaParsers: {
    enum: (schema: any, typeName: any) => any;
    object: (schema: any, typeName: any) => any;
    complex: (schema: any, typeName: any) => any;
    primitive: (schema: any, typeName: any) => any;
    discriminator: (schema: any, typeName: any) => any;
    array: (schema: any, typeName: any) => any;
  };
  parseSchema: () => any;
  getInlineParseContent: () => any;
  getParseContent: () => any;
  extractSchemaFromResponseStruct: (responseStruct: any) => any;
}
//#endregion
//#region src/component-type-name-resolver.d.ts
declare class ComponentTypeNameResolver extends NameResolver {
  counter: number;
  fallbackNameCounter: number;
  countersByVariant: Map<string, number>;
  constructor(config: CodeGenConfig, reservedNames: string[]);
}
declare namespace constants_d_exports {
  export { DEFAULT_BODY_ARG_NAME, FILE_PREFIX, HTTP_CLIENT, PROJECT_VERSION, RESERVED_BODY_ARG_NAMES, RESERVED_HEADER_ARG_NAMES, RESERVED_PATH_ARG_NAMES, RESERVED_QUERY_ARG_NAMES, RESERVED_REQ_PARAMS_ARG_NAMES, SCHEMA_TYPES$1 as SCHEMA_TYPES };
}
declare const DEFAULT_BODY_ARG_NAME = "data";
declare const FILE_PREFIX = "/* eslint-disable */\n/* tslint:disable */\n// @ts-nocheck\n/*\n * ---------------------------------------------------------------\n * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##\n * ##                                                           ##\n * ## AUTHOR: acacode                                           ##\n * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##\n * ---------------------------------------------------------------\n */\n\n";
declare const HTTP_CLIENT: {
  readonly FETCH: "fetch";
  readonly AXIOS: "axios";
};
declare const PROJECT_VERSION: string;
declare const RESERVED_BODY_ARG_NAMES: string[];
declare const RESERVED_HEADER_ARG_NAMES: string[];
declare const RESERVED_PATH_ARG_NAMES: string[];
declare const RESERVED_QUERY_ARG_NAMES: string[];
declare const RESERVED_REQ_PARAMS_ARG_NAMES: string[];
declare const SCHEMA_TYPES$1: {
  readonly ARRAY: "array";
  readonly OBJECT: "object";
  readonly ENUM: "enum";
  readonly REF: "$ref";
  readonly PRIMITIVE: "primitive";
  readonly COMPLEX: "complex";
  readonly DISCRIMINATOR: "discriminator";
  readonly COMPLEX_ONE_OF: "oneOf";
  readonly COMPLEX_ANY_OF: "anyOf";
  readonly COMPLEX_ALL_OF: "allOf";
  readonly COMPLEX_NOT: "not";
  readonly COMPLEX_UNKNOWN: "__unknown";
};
//#endregion
//#region src/schema-parser/mono-schema-parser.d.ts
declare class MonoSchemaParser {
  schema: any;
  typeName: any;
  schemaPath: never[];
  schemaParser: SchemaParser;
  schemaParserFabric: SchemaParserFabric;
  typeNameFormatter: TypeNameFormatter;
  schemaComponentsMap: SchemaComponentsMap;
  schemaUtils: SchemaUtils;
  config: CodeGenConfig;
  schemaFormatters: SchemaFormatters;
  constructor(schemaParser: SchemaParser, schema: any, typeName?: null, schemaPath?: never[]);
  parse(): void;
  buildTypeNameFromPath: () => Capitalize<string> | null;
}
//#endregion
//#region types/index.d.ts
type HttpClientType = (typeof HTTP_CLIENT)[keyof typeof HTTP_CLIENT];
type BuildRouteParam = {
  /** {bar} */
  $match: string;
  name: string;
  required: boolean;
  type: "string";
  description: string;
  schema: {
    type: string;
  };
  in: "path" | "query";
};
type BuildRoutePath = {
  /** /foo/{bar}/baz */
  originalRoute: string;
  /** /foo/${bar}/baz */
  route: string;
  pathParams: BuildRouteParam[];
  queryParams: BuildRouteParam[];
};
interface Hooks {
  /** calls before parse\process route path */
  onPreBuildRoutePath: (routePath: string) => string | undefined;
  /** calls after parse\process route path */
  onBuildRoutePath: (data: BuildRoutePath) => BuildRoutePath | undefined;
  /** calls before insert path param name into string path interpolation */
  onInsertPathParam: (paramName: string, index: number, arr: BuildRouteParam[], resultRoute: string) => string | undefined;
  /** calls after parse schema component */
  onCreateComponent: (component: SchemaComponent) => SchemaComponent | undefined;
  /** calls before parse any kind of schema */
  onPreParseSchema: (originalSchema: unknown, typeName: string, schemaType: string) => undefined;
  /** calls after parse any kind of schema */
  onParseSchema: (originalSchema: unknown, parsedSchema: unknown) => unknown | undefined;
  /** calls after parse route (return type: customized route (ParsedRoute), nothing change (void), false (ignore this route)) */
  onCreateRoute: (routeData: ParsedRoute) => ParsedRoute | false | undefined;
  /** Start point of work this tool (after fetching schema) */
  onInit?: <C extends GenerateApiConfiguration["config"]>(configuration: C, codeGenProcess: CodeGenProcess) => C | undefined;
  /** customize configuration object before sending it to ETA templates */
  onPrepareConfig?: <C extends GenerateApiConfiguration>(currentConfiguration: C) => C | undefined;
  /** customize route name as you need */
  onCreateRouteName?: (routeNameInfo: RouteNameInfo, rawRouteInfo: RawRouteInfo) => RouteNameInfo | undefined;
  /** customize request params (path params, query params) */
  onCreateRequestParams?: (rawType: SchemaComponent["rawTypeData"]) => SchemaComponent["rawTypeData"] | undefined;
  /** customize name of model type */
  onFormatTypeName?: (typeName: string, rawTypeName?: string, schemaType?: "type-name" | "enum-key") => string | undefined;
  /** customize name of route (operationId), you can do it with using onCreateRouteName too */
  onFormatRouteName?: (routeInfo: RawRouteInfo, templateRouteName: string) => string | undefined;
}
type RouteNameInfo = {
  usage: string;
  original: string;
  duplicate: boolean;
};
type SchemaTypePrimitiveContent = {
  $parsedSchema: boolean;
  schemaType: string;
  type: string;
  typeIdentifier: string;
  name?: unknown;
  description: string;
  content: string;
};
type SchemaTypeObjectContent = {
  $$raw: {
    type: string;
    required: boolean;
    $parsed: SchemaTypePrimitiveContent;
  };
  isRequired: boolean;
  field: string;
}[];
type SchemaTypeEnumContent = {
  key: string;
  type: string;
  value: string;
};
interface ParsedSchema<C> {
  $parsedSchema: boolean;
  schemaType: string;
  type: string;
  typeIdentifier: string;
  name: string;
  description?: string;
  allFieldsAreOptional?: boolean;
  content: C;
  isExtractedRequestParams?: boolean;
  isExtractedRequestBody?: boolean;
  isExtractedResponseBody?: boolean;
  isExtractedResponseError?: boolean;
}
interface SchemaComponent {
  $ref: string;
  typeName: string;
  rawTypeData?: {
    type: string;
    required?: string[];
    properties?: Record<string, {
      name?: string;
      type: string;
      required: boolean;
      $parsed?: SchemaTypePrimitiveContent;
    }>;
    discriminator?: {
      propertyName?: string;
    };
    $parsed: ParsedSchema<SchemaTypeObjectContent | SchemaTypeEnumContent | SchemaTypePrimitiveContent>;
  };
  componentName: "schemas" | "paths";
  typeData: ParsedSchema<SchemaTypeObjectContent | SchemaTypeEnumContent | SchemaTypePrimitiveContent> | null;
}
declare enum RequestContentKind {
  JSON = "JSON",
  URL_ENCODED = "URL_ENCODED",
  FORM_DATA = "FORM_DATA",
  IMAGE = "IMAGE",
  OTHER = "OTHER",
  TEXT = "TEXT",
}
interface RequestResponseInfo {
  contentTypes: string[];
  contentKind: RequestContentKind;
  type: string;
  description: string;
  status: string | number;
  isSuccess: boolean;
}
type RawRouteInfo = {
  operationId: string;
  method: string;
  route: string;
  moduleName: string;
  responsesTypes: RequestResponseInfo[];
  description?: string;
  tags?: string[];
  summary?: string;
  responses?: swagger_schema_official16.Spec["responses"];
  produces?: string[];
  requestBody?: object;
  consumes?: string[];
};
interface ParsedRouteRequest {
  contentTypes?: string[];
  formData?: boolean;
  headers?: {
    name: string | null;
    optional: boolean | undefined;
    type: Record<string, any>;
  };
  isQueryBody?: boolean;
  method?: string;
  parameters?: Record<string, unknown>[];
  path?: string;
  pathParams?: Record<string, unknown>;
  payload?: {
    name: string | null;
    optional?: boolean;
    type: string;
  };
  query?: Record<string, unknown>;
  requestParams?: Record<string, unknown> | null;
  security?: boolean;
}
interface ParsedRouteResponse {
  contentTypes?: string[];
  errorType?: string;
  fullTypes?: string;
  type?: string;
}
interface ParsedRoute {
  id: string;
  namespace: string;
  routeParams?: Record<string, any>;
  requestBodyInfo?: {
    paramName: any;
    contentTypes: any[];
    contentKind: string;
    schema: any;
    type: any;
    required: any;
  };
  responseBodyInfo?: {
    contentTypes: any[];
    responses: any[];
    success?: Record<string, any>;
    error?: Record<string, any>;
    full?: Record<string, any>;
  };
  specificArgs?: Record<string, any>;
  queryObjectSchema?: Record<string, any>;
  pathObjectSchema?: Record<string, any>;
  headersObjectSchema?: Record<string, any>;
  responseBodySchema?: Record<string, any>;
  requestBodySchema?: Record<string, any>;
  specificArgNameResolver?: Record<string, any>;
  request: ParsedRouteRequest;
  response: ParsedRouteResponse;
  routeName: RouteNameInfo;
  raw: RawRouteInfo;
}
type ModelType = {
  typeIdentifier: string;
  name: string;
  rawContent: string;
  description: string;
  content: string;
};
declare enum SCHEMA_TYPES {
  ARRAY = "array",
  OBJECT = "object",
  ENUM = "enum",
  REF = "$ref",
  PRIMITIVE = "primitive",
  COMPLEX = "complex",
  COMPLEX_ONE_OF = "oneOf",
  COMPLEX_ANY_OF = "anyOf",
  COMPLEX_ALL_OF = "allOf",
  COMPLEX_NOT = "not",
  COMPLEX_UNKNOWN = "__unknown",
}
type MAIN_SCHEMA_TYPES = SCHEMA_TYPES.PRIMITIVE | SCHEMA_TYPES.OBJECT | SCHEMA_TYPES.ENUM;
type ExtractingOptions = {
  requestBodySuffix: string[];
  responseBodySuffix: string[];
  responseErrorSuffix: string[];
  requestParamsSuffix: string[];
  enumSuffix: string[];
  discriminatorMappingSuffix: string[];
  discriminatorAbstractPrefix: string[];
  requestBodyNameResolver: (name: string, reservedNames: string) => string | undefined;
  responseBodyNameResolver: (name: string, reservedNames: string) => string | undefined;
  responseErrorNameResolver: (name: string, reservedNames: string) => string | undefined;
  requestParamsNameResolver: (name: string, reservedNames: string) => string | undefined;
  enumNameResolver: (name: string, reservedNames: string) => string | undefined;
  discriminatorMappingNameResolver: (name: string, reservedNames: string) => string | undefined;
  discriminatorAbstractResolver: (name: string, reservedNames: string) => string | undefined;
};
interface GenerateApiConfiguration {
  apiConfig: {
    baseUrl: string;
    title: string;
    version: string;
    description: string[];
    hasDescription: boolean;
  };
  config: {
    input: string;
    output: string | false;
    url: string;
    spec: unknown;
    fileName: string;
    templatePaths: {
      /** `templates/base` */
      base: string;
      /** `templates/default` */
      default: string;
      /** `templates/modular` */
      modular: string;
      /** usage path if `--templates` option is not set */
      original: string;
      /** custom path to templates (`--templates`) */
      custom: string | null;
    };
    authorizationToken?: string;
    generateResponses: boolean;
    defaultResponseAsSuccess: boolean;
    generateRouteTypes: boolean;
    generateClient: boolean;
    generateUnionEnums: boolean;
    swaggerSchema: object;
    originalSchema: object;
    componentsMap: Record<string, SchemaComponent>;
    convertedFromSwagger2: boolean;
    moduleNameIndex: number;
    moduleNameFirstTag: boolean;
    extraTemplates: {
      name: string;
      path: string;
    }[];
    extractRequestParams: boolean;
    unwrapResponseData: boolean;
    sortTypes: boolean;
    sortRoutes: boolean;
    singleHttpClient: boolean;
    typePrefix: string;
    typeSuffix: string;
    enumKeyPrefix: string;
    enumKeySuffix: string;
    patch: boolean;
    cleanOutput: boolean;
    debug: boolean;
    anotherArrayType: boolean;
    extractRequestBody: boolean;
    httpClientType: "axios" | "fetch";
    addReadonly: boolean;
    extractResponseBody: boolean;
    extractResponseError: boolean;
    extractEnums: boolean;
    extractResponses: boolean;
    fixInvalidTypeNamePrefix: string;
    fixInvalidEnumKeyPrefix: string;
    defaultResponseType: string;
    toJS: boolean;
    disableThrowOnError: boolean;
    silent: boolean;
    hooks: Partial<Hooks>;
    enumNamesAsValues: boolean;
    version: string;
    compilerTsConfig: Record<string, unknown>;
    enumKeyResolverName: string;
    typeNameResolverName: string;
    specificArgNameResolverName: string;
    customTranslator?: new () => Translator;
    internalTemplateOptions: {
      addUtilRequiredKeysType: boolean;
    };
    componentTypeNameResolver: ComponentTypeNameResolver;
    fileNames: {
      dataContracts: string;
      routeTypes: string;
      httpClient: string;
      outOfModuleApi: string;
    };
    templatesToRender: {
      api: string;
      dataContracts: string;
      httpClient: string;
      routeTypes: string;
      routeName: string;
      dataContractJsDoc: string;
      interfaceDataContract: string;
      typeDataContract: string;
      enumDataContract: string;
      objectFieldJsDoc: string;
    };
    routeNameDuplicatesMap: Map<string, string>;
    apiClassName: string;
    requestOptions?: RequestInit;
    extractingOptions: ExtractingOptions;
  };
  modelTypes: ModelType[];
  hasFormDataRoutes: boolean;
  hasSecurityRoutes: boolean;
  hasQueryRoutes: boolean;
  generateResponses: boolean;
  routes: {
    outOfModule: ParsedRoute[];
    combined?: {
      moduleName: string;
      routes: ParsedRoute[];
    }[];
  };
  requestOptions?: Partial<RequestInit>;
  utils: {
    formatDescription: (description: string, inline?: boolean) => string;
    internalCase: (value: string) => string;
    /** @deprecated */
    classNameCase: (value: string) => string;
    pascalCase: (value: string) => string;
    getInlineParseContent: (rawTypeData: SchemaComponent["rawTypeData"], typeName?: string) => string;
    getParseContent: (rawTypeData: SchemaComponent["rawTypeData"], typeName?: string) => ModelType;
    getComponentByRef: (ref: string) => SchemaComponent;
    parseSchema: (rawSchema: string | SchemaComponent["rawTypeData"], typeName?: string, formattersMap?: Record<MAIN_SCHEMA_TYPES, (content: ModelType) => string>) => ModelType;
    formatters: Record<MAIN_SCHEMA_TYPES, (content: string | object | string[] | object[]) => string>;
    inlineExtraFormatters: Record<Exclude<MAIN_SCHEMA_TYPES, SCHEMA_TYPES.PRIMITIVE>, (schema: ModelType) => string>;
    formatModelName: (name: string) => string;
    fmtToJSDocLine: (line: string, params?: {
      eol?: boolean;
    }) => string;
    _: lodash19.LoDashStatic;
    require: (path: string) => unknown;
  };
}
type FileInfo = {
  /** @example myFilename */
  fileName: string;
  /** @example .d.ts */
  fileExtension: string;
  /** content of the file */
  fileContent: string;
};
interface GenerateApiOutput {
  configuration: GenerateApiConfiguration;
  files: FileInfo[];
  createFile: (params: {
    path: string;
    fileName: string;
    content: string;
    withPrefix: boolean;
  }) => void;
  renderTemplate: (templateContent: string, data: Record<string, unknown>, etaOptions?: Partial<eta20.EtaConfig>) => Promise<string> | string;
  getTemplate: (params: {
    fileName?: string;
    name?: string;
    path?: string;
  }) => string;
  formatTSContent: (content: string) => Promise<string>;
}
interface GenerateTemplatesParams {
  cleanOutput?: boolean;
  output?: string;
  httpClientType?: HttpClientType;
  modular?: boolean;
  rewrite?: boolean;
  silent?: boolean;
  debug?: boolean;
}
interface GenerateTemplatesOutput extends Pick<GenerateApiOutput, "files" | "createFile"> {}
//#endregion
//#region src/configuration.d.ts
declare class CodeGenConfig {
  version: string;
  /** CLI flag */
  templates: string;
  /** CLI flag */
  generateResponses: boolean;
  /** CLI flag */
  defaultResponseAsSuccess: boolean;
  /** CLI flag */
  generateRouteTypes: boolean;
  /** CLI flag */
  generateClient: boolean;
  /** CLI flag */
  generateUnionEnums: boolean;
  /** CLI flag */
  addReadonly: boolean;
  enumNamesAsValues: boolean;
  /** parsed swagger schema from getSwaggerObject() */
  /** parsed swagger schema ref */
  swaggerSchema: null;
  /** original (converted to json) swagger schema ref */
  originalSchema: null;
  /** { "#/components/schemas/Foo": @TypeInfo, ... } */
  componentsMap: {};
  /** flag for catching conversion from swagger 2.0 */
  convertedFromSwagger2: boolean;
  /** url index from paths used for merging into modules */
  moduleNameIndex: number;
  /** use the first tag for the module name */
  moduleNameFirstTag: boolean;
  extractRequestParams: boolean;
  extractRequestBody: boolean;
  extractResponseBody: boolean;
  extractResponseError: boolean;
  extractResponses: boolean;
  extractEnums: boolean;
  fileNames: {
    dataContracts: string;
    routeTypes: string;
    httpClient: string;
    outOfModuleApi: string;
  };
  routeNameDuplicatesMap: Map<any, any>;
  hooks: Hooks;
  defaultResponseType: string;
  singleHttpClient: boolean;
  httpClientType: "fetch";
  unwrapResponseData: boolean;
  disableThrowOnError: boolean;
  sortTypes: boolean;
  sortRoutes: boolean;
  templatePaths: {
    /** `templates/base` */
    base: string;
    /** `templates/default` */
    default: string;
    /** `templates/modular` */
    modular: string;
    /** usage path if `--templates` option is not set */
    original: string;
    /** custom path to templates (`--templates`) */
    custom: string;
  };
  /** Record<templateName, templateContent> */
  templatesToRender: {
    api: string;
    dataContracts: string;
    dataContractJsDoc: string;
    interfaceDataContract: string;
    typeDataContract: string;
    enumDataContract: string;
    objectFieldJsDoc: string;
    httpClient: string;
    routeTypes: string;
    routeName: string;
  };
  schemaParsers: Record<string, (...args: unknown[]) => MonoSchemaParser>;
  toJS: boolean;
  silent: boolean;
  typePrefix: string;
  typeSuffix: string;
  enumKeyPrefix: string;
  enumKeySuffix: string;
  patch: boolean;
  componentTypeNameResolver: ComponentTypeNameResolver;
  /** name of the main exported class */
  apiClassName: string;
  debug: boolean;
  anotherArrayType: boolean;
  internalTemplateOptions: {
    addUtilRequiredKeysType: boolean;
  };
  extraTemplates: never[];
  input: string;
  modular: boolean;
  output: string;
  url: string;
  cleanOutput: boolean;
  spec: OpenAPI.Document | null;
  fileName: string;
  authorizationToken: string | undefined;
  requestOptions: null;
  jsPrimitiveTypes: string[];
  jsEmptyTypes: string[];
  fixInvalidTypeNamePrefix: string;
  fixInvalidEnumKeyPrefix: string;
  enumKeyResolverName: string;
  typeNameResolverName: string;
  specificArgNameResolverName: string;
  successResponseStatusRange: number[];
  extractingOptions: Partial<ExtractingOptions>;
  compilerTsConfig: {
    module: typescript.ModuleKind;
    noImplicitReturns: boolean;
    alwaysStrict: boolean;
    target: typescript.ScriptTarget;
    declaration: boolean;
    noImplicitAny: boolean;
    sourceMap: boolean;
    removeComments: boolean;
    disableSizeLimit: boolean;
    esModuleInterop: boolean;
    emitDecoratorMetadata: boolean;
    skipLibCheck: boolean;
  };
  customTranslator?: new () => Translator;
  Ts: {
    Keyword: {
      Number: string;
      String: string;
      Boolean: string;
      Any: string;
      Void: string;
      Unknown: string;
      Null: string;
      Undefined: string;
      Object: string;
      File: string;
      Date: string;
      Type: string;
      Enum: string;
      Interface: string;
      Array: string;
      Record: string;
      Intersection: string;
      Union: string;
    };
    CodeGenKeyword: {
      UtilRequiredKeys: string;
    };
    /**
     * $A[] or Array<$A>
     */
    ArrayType: (content: unknown) => string;
    /**
     * "$A"
     */
    StringValue: (content: unknown) => string;
    /**
     * $A
     */
    BooleanValue: (content: unknown) => string;
    /**
     * $A
     */
    NumberValue: (content: unknown) => string;
    /**
     * $A
     */
    NullValue: () => string;
    /**
     * $A1 | $A2
     */
    UnionType: (contents: unknown[]) => string;
    /**
     * ($A1)
     */
    ExpressionGroup: (content: unknown) => string;
    /**
     * $A1 & $A2
     */
    IntersectionType: (contents: unknown[]) => string;
    /**
     * Record<$A1, $A2>
     */
    RecordType: (key: unknown, value: unknown) => string;
    /**
     * readonly $key?:$value
     */
    TypeField: ({
      readonly,
      key,
      optional,
      value
    }: Record<string, unknown>) => string;
    /**
     * [key: $A1]: $A2
     */
    InterfaceDynamicField: (key: unknown, value: unknown) => string;
    /**
     * EnumName.EnumKey
     */
    EnumUsageKey: (enumStruct: unknown, key: unknown) => string;
    /**
     * $A1 = $A2
     */
    EnumField: (key: unknown, value: unknown) => string;
    /**
     * /\** description \*\/
     */
    EnumFieldDescription: (description: any) => string;
    /**
     * /\** $A0.description \*\/
     * $A0.key = $A0.value,
     * /\** $A1.description \*\/
     * $A1.key = $A1.value,
     * /\** $AN.description \*\/
     * $AN.key = $AN.value,
     */
    EnumFieldsWrapper: (contents: Record<string, unknown>[]) => string;
    /**
     * {\n $A \n}
     */
    ObjectWrapper: (content: unknown) => string;
    /**
     * /** $A *\/
     */
    MultilineComment: (contents: unknown[], formatFn: (arg: unknown) => unknown) => string[];
    /**
     * $A1<...$A2.join(,)>
     */
    TypeWithGeneric: (typeName: unknown, genericArgs: unknown[]) => string;
    /**
     * [$A1, $A2, ...$AN]
     */
    Tuple: (values: unknown[]) => string;
  };
  /**
   * swagger schema type -> typescript type
   * https://json-schema.org/understanding-json-schema/reference/string.html#dates-and-times
   */
  primitiveTypes: Record<string, string | ((schema: OpenAPI.Document, parser: SchemaParser) => string) | ({
    $default: string;
  } & Record<string, string | ((schema: OpenAPI.Document, parser: SchemaParser) => string)>)>;
  templateInfos: {
    name: string;
    fileName: string;
  }[];
  templateExtensions: string[];
  constructor({
    codeGenConstructs,
    primitiveTypeConstructs,
    constants,
    templateInfos,
    hooks,
    ...otherConfig
  }: Partial<GenerateApiConfiguration["config"]>);
  update: (update: Partial<GenerateApiConfiguration["config"]>) => void;
}
//#endregion
//#region src/code-formatter.d.ts
declare class CodeFormatter {
  config: CodeGenConfig;
  constructor(config: CodeGenConfig);
  removeUnusedImports: (content: string) => string;
  format: (content: string) => Promise<string>;
  formatCode: (code: string, {
    removeUnusedImports,
    format
  }?: {
    removeUnusedImports?: boolean | undefined;
    format?: boolean | undefined;
  }) => Promise<string>;
}
//#endregion
//#region src/translators/translator.d.ts
interface TranslatorIO {
  fileName: string;
  fileExtension: string;
  fileContent: string;
}
declare class Translator {
  config: CodeGenConfig;
  codeFormatter: CodeFormatter;
  constructor(config: CodeGenConfig, codeFormatter: CodeFormatter);
  translate(_input: TranslatorIO): Promise<TranslatorIO[]>;
}
//#endregion
//#region src/commands/generate-templates/index.d.ts
declare function generateTemplates(config: GenerateTemplatesParams): Promise<GenerateTemplatesOutput>;
//#endregion
//#region src/index.d.ts
declare function generateApi(config: Partial<GenerateApiConfiguration["config"]>): Promise<{
  files: TranslatorIO[];
  configuration: GenerateApiConfiguration | {
    apiConfig: {
      info: any;
      servers: any;
      basePath: any;
      host: any;
      externalDocs: any;
      tags: unknown[];
      baseUrl: any;
      title: any;
      version: any;
    };
    config: CodeGenConfig;
    modelTypes: any[];
    hasSecurityRoutes: boolean;
    hasQueryRoutes: boolean;
    hasFormDataRoutes: boolean;
    generateResponses: boolean;
    routes: {
      outOfModule: ParsedRoute[];
      combined?: {
        moduleName: string;
        routes: ParsedRoute[];
      }[];
    };
    extraTemplates: never[];
    fileName: string;
    translateToJavaScript: boolean;
    customTranslator: Translator | null;
    utils: {
      Ts: {
        Keyword: {
          Number: string;
          String: string;
          Boolean: string;
          Any: string;
          Void: string;
          Unknown: string;
          Null: string;
          Undefined: string;
          Object: string;
          File: string;
          Date: string;
          Type: string;
          Enum: string;
          Interface: string;
          Array: string;
          Record: string;
          Intersection: string;
          Union: string;
        };
        CodeGenKeyword: {
          UtilRequiredKeys: string;
        };
        ArrayType: (content: unknown) => string;
        StringValue: (content: unknown) => string;
        BooleanValue: (content: unknown) => string;
        NumberValue: (content: unknown) => string;
        NullValue: () => string;
        UnionType: (contents: unknown[]) => string;
        ExpressionGroup: (content: unknown) => string;
        IntersectionType: (contents: unknown[]) => string;
        RecordType: (key: unknown, value: unknown) => string;
        TypeField: ({
          readonly,
          key,
          optional,
          value
        }: Record<string, unknown>) => string;
        InterfaceDynamicField: (key: unknown, value: unknown) => string;
        EnumUsageKey: (enumStruct: unknown, key: unknown) => string;
        EnumField: (key: unknown, value: unknown) => string;
        EnumFieldDescription: (description: any) => string;
        EnumFieldsWrapper: (contents: Record<string, unknown>[]) => string;
        ObjectWrapper: (content: unknown) => string;
        MultilineComment: (contents: unknown[], formatFn: (arg: unknown) => unknown) => string[];
        TypeWithGeneric: (typeName: unknown, genericArgs: unknown[]) => string;
        Tuple: (values: unknown[]) => string;
      };
      formatDescription: (description: any, inline: any) => any;
      internalCase: typeof internalCase;
      classNameCase: typeof pascalCase;
      pascalCase: typeof pascalCase;
      getInlineParseContent: (schema: string, typeName: string | null, schemaPath: string[]) => Record<string, any>;
      getParseContent: (schema: string, typeName: string | null, schemaPath: string[]) => Record<string, any>;
      getComponentByRef: ($ref: string) => SchemaComponent | null;
      parseSchema: (schema: string, typeName?: string | null, schemaPath?: string[]) => ParsedSchema<SchemaTypeObjectContent | SchemaTypeEnumContent | SchemaTypePrimitiveContent>;
      checkAndAddNull: (schema: any, type: any) => any;
      safeAddNullToType: (schema: any, type: any) => any;
      isNeedToAddNull: (schema: any, type: any) => any;
      inlineExtraFormatters: {
        enum: (parsedSchema: any) => any;
        object: (parsedSchema: any) => any;
      };
      formatters: {
        enum: (parsedSchema: any) => any;
        object: (parsedSchema: any) => any;
        primitive: (parsedSchema: any) => any;
      };
      formatModelName: (name: string, options?: {
        type?: "enum-key" | "type-name";
      }) => string | undefined;
      fmtToJSDocLine: (line: string, {
        eol
      }: {
        eol?: boolean | undefined;
      }) => string;
      NameResolver: typeof NameResolver;
      _: lodash14.LoDashStatic;
      require: (packageOrPath: string) => Promise<any>;
    };
  };
  getTemplate: (name: string, fileName: string, path?: string) => string | undefined;
  renderTemplate: (template: string, configuration: object, options?: object) => string;
  createFile: ({
    path: path_,
    fileName,
    content,
    withPrefix
  }: {
    path: any;
    fileName: any;
    content: any;
    withPrefix: any;
  }) => void;
  formatTSContent: (code: string, {
    removeUnusedImports,
    format
  }?: {
    removeUnusedImports?: boolean | undefined;
    format?: boolean | undefined;
  }) => Promise<string>;
}>;
//#endregion
export { constants_d_exports as constants, generateApi, generateTemplates };
//# sourceMappingURL=lib.d.cts.map