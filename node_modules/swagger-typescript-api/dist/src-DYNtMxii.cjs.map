{"version":3,"file":"src-DYNtMxii.cjs","names":["config: CodeGenConfig","content: string","content","Distribution","code: string","fileName: string","encoding: string","path: string","path","config: CodeGenConfig","reservedNames: string[]","getFallbackName: Resolver","names: string[]","name","name: string","variants: string[]","resolver?: Resolver","extras?: string[]","usageName: string | null","config: CodeGenConfig","reservedNames: string[]","packageJson","target: object","updater: Updater | unknown","_routePath: unknown","_routeData: unknown","_pathParam: unknown","schema: SchemaComponent","_originalSchema: unknown","_typeName: unknown","_schemaType: unknown","parsedSchema: unknown","routeData: unknown","config: unknown","_codeGenProcess: unknown","apiConfig: unknown","_rawType: unknown","_rawTypeName: unknown","_routeInfo: unknown","_templateRouteName: unknown","content: unknown","contents: unknown[]","key: unknown","value: unknown","enumStruct: unknown","description: any","description","contents: Record<string, unknown>[]","formatFn: (arg: unknown) => unknown","typeName: unknown","genericArgs: unknown[]","values: unknown[]","CONSTANTS","update: Partial<GenerateApiConfiguration[\"config\"]>","config: CodeGenConfig","paths: string[]","ref: string","$ref: string","rawTypeData: SchemaComponent[\"rawTypeData\"]","componentSchema: SchemaComponent","schemaParser: SchemaParser | SchemaParserFabric","parsedSchema: Record<string, any>","formatType: \"base\" | \"inline\"","description","propertyName: string","o1: Record<string, any>","o2: Record<string, any>","schemaParser: SchemaParser","type","description","content","config: CodeGenConfig","reservedNames: string[]","enumNames","name","interfaceKeysContent: any","type","recordKeysContent: any","recordValuesContent: any","description","type","type","type","SchemaParser","value: string","value: string","name","type","config: CodeGenConfig","templatesWorker: TemplatesWorker","schemaComponentsMap: SchemaComponentsMap","typeNameFormatter: TypeNameFormatter","schemaWalker: SchemaWalker","schema: string","typeName: string | null","schemaPath: string[]","config: CodeGenConfig","reservedNames: string[]","config: CodeGenConfig","schemaParserFabric: SchemaParserFabric","schemaComponentsMap: SchemaComponentsMap","templatesWorker: TemplatesWorker","typeNameFormatter: TypeNameFormatter","pathParams","fixedRoute","schema","name","routes: ParsedRoute[]","config: CodeGenConfig","swaggerSchemaResolver: SwaggerSchemaResolver","name: string","schema: OpenAPI.Document","name","ref: string","schema: Record<string, unknown>","path","config: CodeGenConfig","requestOptions: Partial<RequestInit>","url","config: CodeGenConfig","fileSystem: FileSystem","url","swaggerSchema: OpenAPI.Document","converterOptions: { patch?: boolean }","pathToSwagger: string","urlToSwagger: string","authToken?: string","file: string","config: CodeGenConfig","fileSystem: FileSystem","getRenderTemplateData: CodeGenProcess[\"getRenderTemplateData\"]","__dirname","path: string","path","path_: string","fileName: string","packageOrPath: string","name: string","path?: string","name","template: string","configuration: object","options: object","configuration","options","config: CodeGenConfig","codeFormatter: CodeFormatter","_input: TranslatorIO","input: TranslatorIO","config: CodeGenConfig","name: string","options: { type?: FormattingSchemaType }","name","path: string","path","fileName: string","fs","__dirname","config: Partial<GenerateApiConfiguration[\"config\"]>","componentsToParse: SchemaComponent[]","files","line: string","name","modularApiFileInfos: TranslatorIO[]","config: GenerateTemplatesParams","update: Partial<GenerateTemplatesParams>","__dirname","config: GenerateTemplatesParams","config: GenerateTemplatesParams","config: Partial<GenerateApiConfiguration[\"config\"]>"],"sources":["../src/code-formatter.ts","../src/util/name-resolver.ts","../src/util/random.ts","../src/component-type-name-resolver.ts","../package.json","../src/constants.ts","../src/util/object-assign.ts","../src/configuration.ts","../src/schema-components-map.ts","../src/schema-parser/schema-formatters.ts","../src/util/sort-by-property.ts","../src/schema-parser/mono-schema-parser.ts","../src/schema-parser/base-schema-parsers/array.ts","../src/schema-parser/base-schema-parsers/complex.ts","../src/schema-parser/base-schema-parsers/discriminator.ts","../src/schema-parser/util/enum-key-resolver.ts","../src/schema-parser/base-schema-parsers/enum.ts","../src/schema-parser/base-schema-parsers/object.ts","../src/schema-parser/base-schema-parsers/primitive.ts","../src/schema-parser/complex-schema-parsers/all-of.ts","../src/schema-parser/complex-schema-parsers/any-of.ts","../src/schema-parser/complex-schema-parsers/not.ts","../src/schema-parser/complex-schema-parsers/one-of.ts","../src/schema-parser/schema-parser.ts","../src/util/internal-case.ts","../src/util/pascal-case.ts","../src/schema-parser/schema-utils.ts","../src/schema-parser/schema-parser-fabric.ts","../src/util/id.ts","../src/schema-routes/util/specific-arg-name-resolver.ts","../src/schema-routes/schema-routes.ts","../src/schema-walker.ts","../src/util/request.ts","../src/swagger-schema-resolver.ts","../src/templates-worker.ts","../src/translators/translator.ts","../src/translators/javascript.ts","../src/type-name-formatter.ts","../src/util/file-system.ts","../src/code-gen-process.ts","../src/commands/generate-templates/configuration.ts","../src/commands/generate-templates/templates-gen-process.ts","../src/commands/generate-templates/index.ts","../src/index.ts"],"sourcesContent":["import * as path from \"node:path\";\nimport { Biome, Distribution } from \"@biomejs/js-api\";\nimport * as nanoid from \"nanoid\";\nimport * as typescript from \"typescript\";\nimport type { CodeGenConfig } from \"./configuration.js\";\n\nexport class CodeFormatter {\n  config: CodeGenConfig;\n\n  constructor(config: CodeGenConfig) {\n    this.config = config;\n  }\n\n  removeUnusedImports = (content: string) => {\n    const tempFileName = \"file.ts\";\n\n    const host = new TsLanguageServiceHost(tempFileName, content);\n    const languageService = typescript.createLanguageService(host);\n\n    const fileTextChanges = languageService.organizeImports(\n      { type: \"file\", fileName: tempFileName },\n      { newLineCharacter: typescript.sys.newLine },\n      undefined,\n    )[0];\n\n    if (fileTextChanges?.textChanges.length) {\n      return fileTextChanges.textChanges.reduceRight(\n        (content, { span, newText }) =>\n          `${content.slice(0, span.start)}${newText}${content.slice(\n            span.start + span.length,\n          )}`,\n        content,\n      );\n    }\n\n    return content;\n  };\n\n  format = async (content: string) => {\n    const biome = await Biome.create({ distribution: Distribution.NODE });\n    const biomeProject = biome.openProject();\n    biome.applyConfiguration(biomeProject.projectKey, {\n      files: { maxSize: Number.MAX_SAFE_INTEGER },\n      formatter: { indentStyle: \"space\" },\n    });\n    const formatted = biome.formatContent(biomeProject.projectKey, content, {\n      filePath: path.format({ name: nanoid.nanoid(), ext: \"ts\" }),\n    });\n    return formatted.content;\n  };\n\n  formatCode = async (\n    code: string,\n    { removeUnusedImports = true, format = true } = {},\n  ) => {\n    if (removeUnusedImports) {\n      code = this.removeUnusedImports(code);\n    }\n    if (format) {\n      code = await this.format(code);\n    }\n    return code;\n  };\n}\n\nclass TsLanguageServiceHost {\n  fileName: string;\n  content: string;\n  compilerOptions: typescript.CompilerOptions;\n\n  constructor(fileName: string, content: string) {\n    this.fileName = fileName;\n    this.content = content;\n    const tsconfig = typescript.findConfigFile(\n      fileName,\n      typescript.sys.fileExists,\n    );\n    this.compilerOptions = tsconfig\n      ? typescript.convertCompilerOptionsFromJson(\n          typescript.readConfigFile(tsconfig, typescript.sys.readFile).config\n            .compilerOptions,\n          \"\",\n        ).options\n      : typescript.getDefaultCompilerOptions();\n  }\n\n  getNewLine() {\n    return \"newLine\" in typescript.sys ? typescript.sys.newLine : \"\\n\";\n  }\n  getScriptFileNames() {\n    return [this.fileName];\n  }\n  getCompilationSettings() {\n    return this.compilerOptions;\n  }\n  getDefaultLibFileName() {\n    return typescript.getDefaultLibFileName(this.getCompilationSettings());\n  }\n  getCurrentDirectory() {\n    return process.cwd();\n  }\n  getScriptVersion() {\n    return typescript.version;\n  }\n  getScriptSnapshot() {\n    return typescript.ScriptSnapshot.fromString(this.content);\n  }\n  readFile(fileName: string, encoding: string) {\n    if (fileName === this.fileName) {\n      return this.content;\n    }\n\n    return typescript.sys.readFile(fileName, encoding);\n  }\n  fileExists(path: string) {\n    return typescript.sys.fileExists(path);\n  }\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport type { CodeGenConfig } from \"../configuration.js\";\n\ntype Resolver = (reserved: string[], extras?: string[]) => string;\n\nexport class NameResolver {\n  reservedNames: string[] = [];\n  getFallbackName: Resolver;\n\n  config: CodeGenConfig;\n\n  constructor(\n    config: CodeGenConfig,\n    reservedNames: string[],\n    getFallbackName: Resolver,\n  ) {\n    this.config = config;\n    this.getFallbackName = getFallbackName;\n    this.reserve(reservedNames);\n  }\n\n  reserve(names: string[]) {\n    const fixedNames = lodash.uniq(lodash.compact(names));\n    for (const name of fixedNames) {\n      if (this.reservedNames.indexOf(name) === -1) {\n        this.reservedNames.push(name);\n      }\n    }\n  }\n\n  unreserve(names: string[]) {\n    this.reservedNames = this.reservedNames.filter(\n      (reservedName) => !names.some((name) => name === reservedName),\n    );\n  }\n\n  isReserved(name: string) {\n    return this.reservedNames.some((reservedName) => reservedName === name);\n  }\n\n  resolve(\n    variants: string[],\n    resolver?: Resolver,\n    extras?: string[],\n    shouldReserve = true,\n  ): string | null {\n    if (typeof resolver === \"function\") {\n      let usageName: string | null = null;\n      while (usageName === null) {\n        const variant = resolver(variants, extras);\n\n        if (variant === undefined) {\n          consola.warn(\n            \"unable to resolve name. current reserved names: \",\n            ...this.reservedNames,\n          );\n          return null;\n        }\n        if (!shouldReserve || !this.isReserved(variant)) {\n          usageName = variant;\n        }\n      }\n\n      shouldReserve && this.reserve([usageName]);\n      return usageName;\n    }\n\n    if (Array.isArray(variants)) {\n      let usageName: string | null = null;\n      const uniqVariants = lodash.uniq(lodash.compact(variants));\n\n      for (const variant of uniqVariants) {\n        if (!usageName && (!shouldReserve || !this.isReserved(variant))) {\n          usageName = variant;\n        }\n      }\n\n      if (usageName) {\n        shouldReserve && this.reserve([usageName]);\n        return usageName;\n      }\n\n      consola.debug(\n        \"trying to resolve name with using fallback name generator using variants\",\n        ...variants,\n      );\n      return this.resolve(variants, this.getFallbackName, extras);\n    }\n\n    consola.debug(\n      \"problem with reserving names. current reserved names: \",\n      ...this.reservedNames,\n    );\n    return null;\n  }\n}\n","export const getRandomFloat = (min = 0, max = 1) => {\n  return Math.random() * (max - min) + min;\n};\n\nexport const getRandomInt = (min = 0, max = 1) => {\n  if (min === max) return min;\n\n  return Math.round(getRandomFloat(min, max));\n};\n","import { consola } from \"consola\";\nimport type { CodeGenConfig } from \"./configuration.js\";\nimport { NameResolver } from \"./util/name-resolver.js\";\nimport { getRandomInt } from \"./util/random.js\";\n\nexport class ComponentTypeNameResolver extends NameResolver {\n  counter = 1;\n  fallbackNameCounter = 1;\n  countersByVariant = new Map<string, number>();\n\n  constructor(config: CodeGenConfig, reservedNames: string[]) {\n    super(config, reservedNames, (variants) => {\n      const randomVariant = variants[getRandomInt(0, variants.length - 1)];\n      if (randomVariant) {\n        if (!this.countersByVariant.has(randomVariant)) {\n          this.countersByVariant.set(randomVariant, 0);\n        }\n        const variantCounter =\n          (this.countersByVariant.get(randomVariant) as number) + 1;\n        this.countersByVariant.set(randomVariant, variantCounter);\n        const dirtyResolvedName = `${randomVariant}${variantCounter}`;\n        consola.debug(\n          \"generated dirty resolved type name for component - \",\n          dirtyResolvedName,\n        );\n        return dirtyResolvedName;\n      }\n\n      const fallbackName = `${this.config.componentTypeNameResolver}${this\n        .fallbackNameCounter++}`;\n      consola.debug(\n        \"generated fallback type name for component - \",\n        fallbackName,\n      );\n      return fallbackName;\n    });\n  }\n}\n","{\n  \"name\": \"swagger-typescript-api\",\n  \"version\": \"13.2.7\",\n  \"description\": \"Generate the API client for Fetch or Axios from an OpenAPI Specification\",\n  \"homepage\": \"https://github.com/acacode/swagger-typescript-api\",\n  \"bugs\": \"https://github.com/acacode/swagger-typescript-api/issues\",\n  \"repository\": \"github:acacode/swagger-typescript-api\",\n  \"license\": \"MIT\",\n  \"author\": \"Sergey Volkov <js2me@outlook.com>\",\n  \"maintainers\": [\n    \"Sora Morimoto <sora@morimoto.io>\"\n  ],\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": {\n      \"import\": {\n        \"types\": \"./dist/lib.d.ts\",\n        \"default\": \"./dist/lib.js\"\n      },\n      \"require\": {\n        \"types\": \"./dist/lib.d.cts\",\n        \"default\": \"./dist/lib.cjs\"\n      }\n    }\n  },\n  \"main\": \"./dist/lib.cjs\",\n  \"module\": \"./dist/lib.js\",\n  \"types\": \"./dist/lib.d.cts\",\n  \"bin\": {\n    \"sta\": \"./dist/cli.js\",\n    \"swagger-typescript-api\": \"./dist/cli.js\"\n  },\n  \"files\": [\n    \"dist\",\n    \"templates\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsdown\",\n    \"cli:help\": \"node index.js -h\",\n    \"cli:json\": \"node index.js -r -d -p ./swagger-test-cli.json -n swagger-test-cli.ts\",\n    \"cli:yaml\": \"node index.js -r -d -p ./swagger-test-cli.yaml -n swagger-test-cli.ts\",\n    \"format\": \"biome format --write .\",\n    \"format:check\": \"biome format .\",\n    \"lint\": \"biome check\",\n    \"prepack\": \"tsdown\",\n    \"test\": \"vitest run\",\n    \"typedoc\": \"typedoc\"\n  },\n  \"dependencies\": {\n    \"@biomejs/js-api\": \"1.0.0\",\n    \"@biomejs/wasm-nodejs\": \"2.0.5\",\n    \"@types/swagger-schema-official\": \"^2.0.25\",\n    \"c12\": \"^3.0.4\",\n    \"citty\": \"^0.1.6\",\n    \"consola\": \"^3.4.2\",\n    \"eta\": \"^2.2.0\",\n    \"js-yaml\": \"^4.1.0\",\n    \"lodash\": \"^4.17.21\",\n    \"nanoid\": \"^5.1.5\",\n    \"swagger-schema-official\": \"2.0.0-bab6bed\",\n    \"swagger2openapi\": \"^7.0.8\",\n    \"typescript\": \"~5.8.3\"\n  },\n  \"devDependencies\": {\n    \"@biomejs/biome\": \"2.0.5\",\n    \"@changesets/changelog-github\": \"0.5.1\",\n    \"@changesets/cli\": \"2.29.5\",\n    \"@tsconfig/node18\": \"18.2.4\",\n    \"@tsconfig/strictest\": \"2.0.5\",\n    \"@types/js-yaml\": \"4.0.9\",\n    \"@types/lodash\": \"4.17.18\",\n    \"@types/node\": \"24.0.4\",\n    \"@types/swagger2openapi\": \"7.0.4\",\n    \"axios\": \"1.10.0\",\n    \"openapi-types\": \"12.1.3\",\n    \"tsdown\": \"0.12.9\",\n    \"typedoc\": \"0.28.5\",\n    \"vitest\": \"3.2.4\"\n  },\n  \"packageManager\": \"yarn@4.9.2\",\n  \"engines\": {\n    \"node\": \">=20\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\",\n    \"provenance\": true,\n    \"registry\": \"https://registry.npmjs.org\"\n  },\n  \"typedocOptions\": {\n    \"entryPoints\": [\n      \"src/index.ts\"\n    ],\n    \"skipErrorChecking\": true\n  }\n}\n","import packageJson from \"../package.json\" with { type: \"json\" };\n\nexport const DEFAULT_BODY_ARG_NAME = \"data\";\n\nexport const FILE_PREFIX = `/* eslint-disable */\n/* tslint:disable */\n// @ts-nocheck\n/*\n * ---------------------------------------------------------------\n * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##\n * ##                                                           ##\n * ## AUTHOR: acacode                                           ##\n * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##\n * ---------------------------------------------------------------\n */\n\n`;\n\nexport const HTTP_CLIENT = {\n  FETCH: \"fetch\",\n  AXIOS: \"axios\",\n} as const;\n\nexport const PROJECT_VERSION = packageJson.version;\n\nexport const RESERVED_BODY_ARG_NAMES = [\"data\", \"body\", \"reqBody\"];\n\nexport const RESERVED_HEADER_ARG_NAMES = [\"headers\", \"headersParams\"];\n\nexport const RESERVED_PATH_ARG_NAMES = [\"path\", \"pathParams\"];\n\nexport const RESERVED_QUERY_ARG_NAMES = [\"query\", \"queryParams\", \"queryArg\"];\n\nexport const RESERVED_REQ_PARAMS_ARG_NAMES = [\n  \"params\",\n  \"requestParams\",\n  \"reqParams\",\n  \"httpParams\",\n];\n\nexport const SCHEMA_TYPES = {\n  ARRAY: \"array\",\n  OBJECT: \"object\",\n  ENUM: \"enum\",\n  REF: \"$ref\",\n  PRIMITIVE: \"primitive\",\n  COMPLEX: \"complex\",\n  DISCRIMINATOR: \"discriminator\",\n  COMPLEX_ONE_OF: \"oneOf\",\n  COMPLEX_ANY_OF: \"anyOf\",\n  COMPLEX_ALL_OF: \"allOf\",\n  COMPLEX_NOT: \"not\",\n  COMPLEX_UNKNOWN: \"__unknown\",\n} as const;\n","import lodash from \"lodash\";\n\ntype Updater = (target: unknown) => unknown;\n\nexport const objectAssign = (target: object, updater: Updater | unknown) => {\n  if (!updater) return;\n  const update = typeof updater === \"function\" ? updater(target) : updater;\n  const undefinedKeys = lodash\n    .map(update, (value, key) => value === undefined && key)\n    .filter((key) => typeof key === \"string\");\n  Object.assign(target, lodash.merge(target, update));\n  for (const key of undefinedKeys) {\n    target[key] = undefined;\n  }\n};\n","import lodash from \"lodash\";\nimport type { OpenAPI } from \"openapi-types\";\nimport * as typescript from \"typescript\";\nimport type {\n  ExtractingOptions,\n  GenerateApiConfiguration,\n  Hooks,\n  SchemaComponent,\n} from \"../types/index.js\";\nimport { ComponentTypeNameResolver } from \"./component-type-name-resolver.js\";\nimport * as CONSTANTS from \"./constants.js\";\nimport type { MonoSchemaParser } from \"./schema-parser/mono-schema-parser.js\";\nimport type { SchemaParser } from \"./schema-parser/schema-parser.js\";\nimport type { Translator } from \"./translators/translator.js\";\nimport { objectAssign } from \"./util/object-assign.js\";\n\nconst TsKeyword = {\n  Number: \"number\",\n  String: \"string\",\n  Boolean: \"boolean\",\n  Any: \"any\",\n  Void: \"void\",\n  Unknown: \"unknown\",\n  Null: \"null\",\n  Undefined: \"undefined\",\n  Object: \"object\",\n  File: \"File\",\n  Date: \"Date\",\n  Type: \"type\",\n  Enum: \"enum\",\n  Interface: \"interface\",\n  Array: \"Array\",\n  Record: \"Record\",\n  Intersection: \"&\",\n  Union: \"|\",\n};\n\nconst TsCodeGenKeyword = {\n  UtilRequiredKeys: \"UtilRequiredKeys\",\n};\n\nexport class CodeGenConfig {\n  version = CONSTANTS.PROJECT_VERSION;\n  /** CLI flag */\n  templates = \"\";\n  /** CLI flag */\n  generateResponses = false;\n  /** CLI flag */\n  defaultResponseAsSuccess = false;\n  /** CLI flag */\n  generateRouteTypes = false;\n  /** CLI flag */\n  generateClient = true;\n  /** CLI flag */\n  generateUnionEnums = false;\n  /** CLI flag */\n  addReadonly = false;\n  enumNamesAsValues = false;\n  /** parsed swagger schema from getSwaggerObject() */\n\n  /** parsed swagger schema ref */\n  swaggerSchema = null;\n  /** original (converted to json) swagger schema ref */\n  originalSchema = null;\n\n  /** { \"#/components/schemas/Foo\": @TypeInfo, ... } */\n  componentsMap = {};\n  /** flag for catching conversion from swagger 2.0 */\n  convertedFromSwagger2 = false;\n\n  /** url index from paths used for merging into modules */\n  moduleNameIndex = 0;\n\n  /** use the first tag for the module name */\n  moduleNameFirstTag = false;\n  extractRequestParams = false;\n  extractRequestBody = false;\n  extractResponseBody = false;\n  extractResponseError = false;\n  extractResponses = false;\n  extractEnums = false;\n  fileNames = {\n    dataContracts: \"data-contracts\",\n    routeTypes: \"route-types\",\n    httpClient: \"http-client\",\n    outOfModuleApi: \"Common\",\n  };\n  routeNameDuplicatesMap = new Map();\n  hooks: Hooks = {\n    onPreBuildRoutePath: (_routePath: unknown) => void 0,\n    onBuildRoutePath: (_routeData: unknown) => void 0,\n    onInsertPathParam: (_pathParam: unknown) => void 0,\n    onCreateComponent: (schema: SchemaComponent) => schema,\n    onPreParseSchema: (\n      _originalSchema: unknown,\n      _typeName: unknown,\n      _schemaType: unknown,\n    ) => void 0,\n    onParseSchema: (_originalSchema: unknown, parsedSchema: unknown) =>\n      parsedSchema,\n    onCreateRoute: (routeData: unknown) => routeData,\n    onInit: (config: unknown, _codeGenProcess: unknown) => config,\n    onPrepareConfig: (apiConfig: unknown) => apiConfig,\n    onCreateRequestParams: (_rawType: unknown) => {},\n    onCreateRouteName: () => {},\n    onFormatTypeName: (\n      _typeName: unknown,\n      _rawTypeName: unknown,\n      _schemaType: unknown,\n    ) => {},\n    onFormatRouteName: (_routeInfo: unknown, _templateRouteName: unknown) => {},\n  };\n  defaultResponseType;\n  singleHttpClient = false;\n  httpClientType = CONSTANTS.HTTP_CLIENT.FETCH;\n  unwrapResponseData = false;\n  disableThrowOnError = false;\n  sortTypes = false;\n  sortRoutes = false;\n  templatePaths = {\n    /** `templates/base` */\n    base: \"\",\n    /** `templates/default` */\n    default: \"\",\n    /** `templates/modular` */\n    modular: \"\",\n    /** usage path if `--templates` option is not set */\n    original: \"\",\n    /** custom path to templates (`--templates`) */\n    custom: \"\",\n  };\n  /** Record<templateName, templateContent> */\n  templatesToRender = {\n    api: \"\",\n    dataContracts: \"\",\n    dataContractJsDoc: \"\",\n    interfaceDataContract: \"\",\n    typeDataContract: \"\",\n    enumDataContract: \"\",\n    objectFieldJsDoc: \"\",\n    httpClient: \"\",\n    routeTypes: \"\",\n    routeName: \"\",\n  };\n  schemaParsers: Record<string, (...args: unknown[]) => MonoSchemaParser> = {};\n  toJS = false;\n  silent = false;\n  typePrefix = \"\";\n  typeSuffix = \"\";\n  enumKeyPrefix = \"\";\n  enumKeySuffix = \"\";\n  patch = false;\n  componentTypeNameResolver: ComponentTypeNameResolver;\n  /** name of the main exported class */\n  apiClassName = \"Api\";\n  debug = false;\n  anotherArrayType = false;\n  internalTemplateOptions = {\n    addUtilRequiredKeysType: false,\n  };\n  extraTemplates = [];\n  input = \"\";\n  modular = false;\n  output = \"\";\n  url = \"\";\n  cleanOutput = false;\n  spec: OpenAPI.Document | null = null;\n  fileName = \"Api.ts\";\n  authorizationToken: string | undefined;\n  requestOptions = null;\n\n  jsPrimitiveTypes: string[] = [];\n  jsEmptyTypes: string[] = [];\n  fixInvalidTypeNamePrefix = \"Type\";\n  fixInvalidEnumKeyPrefix = \"Value\";\n\n  enumKeyResolverName = \"Value\";\n  typeNameResolverName = \"ComponentType\";\n  specificArgNameResolverName = \"arg\";\n\n  successResponseStatusRange = [200, 299];\n\n  extractingOptions: Partial<ExtractingOptions> = {\n    requestBodySuffix: [\"Payload\", \"Body\", \"Input\"],\n    requestParamsSuffix: [\"Params\"],\n    responseBodySuffix: [\"Data\", \"Result\", \"Output\"],\n    responseErrorSuffix: [\n      \"Error\",\n      \"Fail\",\n      \"Fails\",\n      \"ErrorData\",\n      \"HttpError\",\n      \"BadResponse\",\n    ],\n    enumSuffix: [\"Enum\"],\n    discriminatorMappingSuffix: [\"Mapping\", \"Mapper\", \"MapType\"],\n    discriminatorAbstractPrefix: [\n      \"Base\",\n      \"Abstract\",\n      \"Discriminator\",\n      \"Internal\",\n      \"Polymorph\",\n    ],\n  };\n\n  compilerTsConfig = {\n    module: typescript.ModuleKind.ESNext,\n    noImplicitReturns: true,\n    alwaysStrict: true,\n    target: typescript.ScriptTarget.ESNext,\n    declaration: true,\n    noImplicitAny: false,\n    sourceMap: false,\n    removeComments: false,\n    disableSizeLimit: true,\n    esModuleInterop: true,\n    emitDecoratorMetadata: true,\n    skipLibCheck: true,\n  };\n  customTranslator?: new () => Translator;\n\n  Ts = {\n    Keyword: structuredClone(TsKeyword),\n    CodeGenKeyword: structuredClone(TsCodeGenKeyword),\n    /**\n     * $A[] or Array<$A>\n     */\n    ArrayType: (content: unknown) => {\n      if (this.anotherArrayType) {\n        return this.Ts.TypeWithGeneric(this.Ts.Keyword.Array, [content]);\n      }\n\n      return `${this.Ts.ExpressionGroup(content)}[]`;\n    },\n    /**\n     * \"$A\"\n     */\n    StringValue: (content: unknown) => `\"${content}\"`,\n    /**\n     * $A\n     */\n    BooleanValue: (content: unknown) => `${content}`,\n    /**\n     * $A\n     */\n    NumberValue: (content: unknown) => `${content}`,\n    /**\n     * $A\n     */\n    NullValue: () => \"null\",\n    /**\n     * $A1 | $A2\n     */\n    UnionType: (contents: unknown[]) =>\n      lodash.join(lodash.uniq(contents), ` ${this.Ts.Keyword.Union} `),\n    /**\n     * ($A1)\n     */\n    ExpressionGroup: (content: unknown) => (content ? `(${content})` : \"\"),\n    /**\n     * $A1 & $A2\n     */\n    IntersectionType: (contents: unknown[]) =>\n      lodash.join(lodash.uniq(contents), ` ${this.Ts.Keyword.Intersection} `),\n    /**\n     * Record<$A1, $A2>\n     */\n    RecordType: (key: unknown, value: unknown) =>\n      this.Ts.TypeWithGeneric(this.Ts.Keyword.Record, [key, value]),\n    /**\n     * readonly $key?:$value\n     */\n    TypeField: ({ readonly, key, optional, value }: Record<string, unknown>) =>\n      lodash\n        .compact([readonly && \"readonly \", key, optional && \"?\", \": \", value])\n        .join(\"\"),\n    /**\n     * [key: $A1]: $A2\n     */\n    InterfaceDynamicField: (key: unknown, value: unknown) =>\n      `[key: ${key}]: ${value}`,\n\n    /**\n     * EnumName.EnumKey\n     */\n    EnumUsageKey: (enumStruct: unknown, key: unknown) => `${enumStruct}.${key}`,\n    /**\n     * $A1 = $A2\n     */\n    EnumField: (key: unknown, value: unknown) => `${key} = ${value}`,\n    /**\n     * /\\** description \\*\\/\n     */\n    EnumFieldDescription: (description: any) => {\n      if (description) {\n        return `  /** ${description} */`;\n      } else {\n        return \"\";\n      }\n    },\n    /**\n     * /\\** $A0.description \\*\\/\n     * $A0.key = $A0.value,\n     * /\\** $A1.description \\*\\/\n     * $A1.key = $A1.value,\n     * /\\** $AN.description \\*\\/\n     * $AN.key = $AN.value,\n     */\n    EnumFieldsWrapper: (contents: Record<string, unknown>[]) =>\n      lodash\n        .map(contents, ({ key, value, description }) => {\n          return [\n            this.Ts.EnumFieldDescription(description),\n            `  ${this.Ts.EnumField(key, value)}`,\n          ]\n            .filter(Boolean)\n            .join(\"\\n\");\n        })\n        .join(\",\\n\"),\n    /**\n     * {\\n $A \\n}\n     */\n    ObjectWrapper: (content: unknown) => `{\\n${content}\\n}`,\n    /**\n     * /** $A *\\/\n     */\n    MultilineComment: (\n      contents: unknown[],\n      formatFn: (arg: unknown) => unknown,\n    ) =>\n      [\n        ...(contents.length === 1\n          ? [`/** ${contents[0]} */`]\n          : [\"/**\", ...contents.map((content) => ` * ${content}`), \" */\"]),\n      ].map((part) => `${formatFn ? formatFn(part) : part}\\n`),\n    /**\n     * $A1<...$A2.join(,)>\n     */\n    TypeWithGeneric: (typeName: unknown, genericArgs: unknown[]) => {\n      return `${typeName}${\n        genericArgs.length ? `<${genericArgs.join(\",\")}>` : \"\"\n      }`;\n    },\n    /**\n     * [$A1, $A2, ...$AN]\n     */\n    Tuple: (values: unknown[]) => {\n      return `[${values.join(\", \")}]`;\n    },\n  };\n\n  /**\n   * swagger schema type -> typescript type\n   * https://json-schema.org/understanding-json-schema/reference/string.html#dates-and-times\n   */\n  primitiveTypes: Record<\n    string,\n    | string\n    | ((schema: OpenAPI.Document, parser: SchemaParser) => string)\n    | ({ $default: string } & Record<\n        string,\n        string | ((schema: OpenAPI.Document, parser: SchemaParser) => string)\n      >)\n  > = {\n    integer: () => this.Ts.Keyword.Number,\n    number: () => this.Ts.Keyword.Number,\n    boolean: () => this.Ts.Keyword.Boolean,\n    object: () => this.Ts.Keyword.Object,\n    file: () => this.Ts.Keyword.File,\n    string: {\n      $default: this.Ts.Keyword.String,\n\n      /** formats */\n      binary: () => this.Ts.Keyword.File,\n      file: () => this.Ts.Keyword.File,\n      \"date-time\": () => this.Ts.Keyword.String,\n      time: () => this.Ts.Keyword.String,\n      date: () => this.Ts.Keyword.String,\n      duration: () => this.Ts.Keyword.String,\n      email: () => this.Ts.Keyword.String,\n      \"idn-email\": () => this.Ts.Keyword.String,\n      \"idn-hostname\": () => this.Ts.Keyword.String,\n      ipv4: () => this.Ts.Keyword.String,\n      ipv6: () => this.Ts.Keyword.String,\n      uuid: () => this.Ts.Keyword.String,\n      uri: () => this.Ts.Keyword.String,\n      \"uri-reference\": () => this.Ts.Keyword.String,\n      \"uri-template\": () => this.Ts.Keyword.String,\n      \"json-pointer\": () => this.Ts.Keyword.String,\n      \"relative-json-pointer\": () => this.Ts.Keyword.String,\n      regex: () => this.Ts.Keyword.String,\n    },\n  };\n\n  templateInfos = [\n    { name: \"api\", fileName: \"api\" },\n    { name: \"dataContracts\", fileName: \"data-contracts\" },\n    { name: \"dataContractJsDoc\", fileName: \"data-contract-jsdoc\" },\n    { name: \"interfaceDataContract\", fileName: \"interface-data-contract\" },\n    { name: \"typeDataContract\", fileName: \"type-data-contract\" },\n    { name: \"enumDataContract\", fileName: \"enum-data-contract\" },\n    { name: \"objectFieldJsDoc\", fileName: \"object-field-jsdoc\" },\n    { name: \"httpClient\", fileName: \"http-client\" },\n    { name: \"routeTypes\", fileName: \"route-types\" },\n    { name: \"routeName\", fileName: \"route-name\" },\n  ];\n\n  templateExtensions = [\".eta\", \".ejs\"];\n\n  constructor({\n    codeGenConstructs,\n    primitiveTypeConstructs,\n    constants,\n    templateInfos,\n    hooks,\n    ...otherConfig\n  }: Partial<GenerateApiConfiguration[\"config\"]>) {\n    objectAssign(this.Ts, codeGenConstructs);\n    objectAssign(this.primitiveTypes, primitiveTypeConstructs);\n\n    this.defaultResponseType = this.Ts.Keyword.Void;\n\n    this.update({\n      ...otherConfig,\n      hooks: lodash.merge(this.hooks, hooks || {}),\n      constants: {\n        ...CONSTANTS,\n        ...constants,\n      },\n      templateInfos: templateInfos || this.templateInfos,\n    });\n\n    this.jsPrimitiveTypes = [\n      this.Ts.Keyword.Number,\n      this.Ts.Keyword.String,\n      this.Ts.Keyword.Boolean,\n    ];\n    this.jsEmptyTypes = [this.Ts.Keyword.Null, this.Ts.Keyword.Undefined];\n    this.componentTypeNameResolver = new ComponentTypeNameResolver(this, []);\n  }\n\n  update = (update: Partial<GenerateApiConfiguration[\"config\"]>) => {\n    objectAssign(this, update);\n  };\n}\n","import type { SchemaComponent } from \"../types/index.js\";\nimport type { CodeGenConfig } from \"./configuration.js\";\n\nexport class SchemaComponentsMap {\n  _data: SchemaComponent[] = [];\n  config: CodeGenConfig;\n\n  constructor(config: CodeGenConfig) {\n    this.config = config;\n  }\n\n  clear() {\n    this._data = [];\n  }\n\n  createRef = (paths: string[]) => {\n    return [\"#\", ...paths].join(\"/\");\n  };\n\n  parseRef = (ref: string) => {\n    return ref.split(\"/\");\n  };\n\n  createComponent(\n    $ref: string,\n    rawTypeData: SchemaComponent[\"rawTypeData\"],\n  ): SchemaComponent {\n    const parsed = this.parseRef($ref);\n    const typeName = parsed[parsed.length - 1]!;\n    const componentName = parsed[\n      parsed.length - 2\n    ] as SchemaComponent[\"componentName\"];\n    const componentSchema: SchemaComponent = {\n      $ref,\n      typeName,\n      rawTypeData,\n      componentName,\n      /** result from schema parser */\n      typeData: null,\n    };\n\n    const usageComponent =\n      this.config.hooks.onCreateComponent(componentSchema) || componentSchema;\n\n    const refIndex = this._data.findIndex((c) => c.$ref === $ref);\n\n    if (refIndex === -1) {\n      this._data.push(usageComponent);\n    } else {\n      this._data[refIndex] = usageComponent;\n    }\n\n    return usageComponent;\n  }\n\n  getComponents() {\n    return this._data;\n  }\n\n  filter(...componentNames: (string[] | string)[]) {\n    return this._data.filter((it) =>\n      componentNames.some((componentName) =>\n        it.$ref.startsWith(`#/components/${componentName}`),\n      ),\n    );\n  }\n\n  get($ref: string) {\n    return this._data.find((c) => c.$ref === $ref) || null;\n  }\n\n  // Ensure enums are at the top of components list\n  enumsFirst() {\n    this._data.sort((a, b) => {\n      if (Object.keys(a.rawTypeData || {}).includes(\"enum\")) return -1;\n      if (Object.keys(b.rawTypeData || {}).includes(\"enum\")) return 1;\n      return 0;\n    });\n  }\n}\n","import lodash from \"lodash\";\nimport type { CodeGenConfig } from \"../configuration.js\";\nimport { SCHEMA_TYPES } from \"../constants.js\";\nimport type { TemplatesWorker } from \"../templates-worker.js\";\nimport type { SchemaParser } from \"./schema-parser.js\";\nimport type { SchemaParserFabric } from \"./schema-parser-fabric.js\";\nimport type { SchemaUtils } from \"./schema-utils.js\";\n\nexport class SchemaFormatters {\n  config: CodeGenConfig;\n  templatesWorker: TemplatesWorker;\n  schemaUtils: SchemaUtils;\n\n  constructor(schemaParser: SchemaParser | SchemaParserFabric) {\n    this.config = schemaParser.config;\n    this.schemaUtils = schemaParser.schemaUtils;\n    this.templatesWorker = schemaParser.templatesWorker;\n  }\n\n  base = {\n    [SCHEMA_TYPES.ENUM]: (parsedSchema) => {\n      if (this.config.generateUnionEnums) {\n        return {\n          ...parsedSchema,\n          $content: parsedSchema.content,\n          content: this.config.Ts.UnionType(\n            parsedSchema.content.map(({ value }) => value),\n          ),\n        };\n      }\n\n      return {\n        ...parsedSchema,\n        $content: parsedSchema.content,\n        content: this.config.Ts.EnumFieldsWrapper(parsedSchema.content),\n      };\n    },\n    [SCHEMA_TYPES.OBJECT]: (parsedSchema) => {\n      if (parsedSchema.nullable)\n        return this.inline[SCHEMA_TYPES.OBJECT](parsedSchema);\n      return {\n        ...parsedSchema,\n        $content: parsedSchema.content,\n        content: this.formatObjectContent(parsedSchema.content),\n      };\n    },\n    [SCHEMA_TYPES.PRIMITIVE]: (parsedSchema) => {\n      return {\n        ...parsedSchema,\n        $content: parsedSchema.content,\n      };\n    },\n  };\n  inline = {\n    [SCHEMA_TYPES.ENUM]: (parsedSchema) => {\n      return {\n        ...parsedSchema,\n        content: parsedSchema.$ref\n          ? parsedSchema.typeName\n          : this.config.Ts.UnionType(\n              lodash.compact([\n                ...parsedSchema.content.map(({ value }) => `${value}`),\n                parsedSchema.nullable && this.config.Ts.Keyword.Null,\n              ]),\n            ) || this.config.Ts.Keyword.Any,\n      };\n    },\n    [SCHEMA_TYPES.OBJECT]: (parsedSchema) => {\n      if (typeof parsedSchema.content === \"string\")\n        return {\n          ...parsedSchema,\n          typeIdentifier: this.config.Ts.Keyword.Type,\n          content: this.schemaUtils.safeAddNullToType(parsedSchema.content),\n        };\n\n      return {\n        ...parsedSchema,\n        typeIdentifier: this.config.Ts.Keyword.Type,\n        content: this.schemaUtils.safeAddNullToType(\n          parsedSchema,\n          parsedSchema.content.length\n            ? this.config.Ts.ObjectWrapper(\n                this.formatObjectContent(parsedSchema.content),\n              )\n            : this.config.Ts.RecordType(\n                this.config.Ts.Keyword.String,\n                this.config.Ts.Keyword.Any,\n              ),\n        ),\n      };\n    },\n  };\n\n  formatSchema = (\n    parsedSchema: Record<string, any>,\n    formatType: \"base\" | \"inline\" = \"base\",\n  ) => {\n    const schemaType =\n      lodash.get(parsedSchema, [\"schemaType\"]) ||\n      lodash.get(parsedSchema, [\"$parsed\", \"schemaType\"]);\n    const formatterFn = lodash.get(this, [formatType, schemaType]);\n    return formatterFn?.(parsedSchema) || parsedSchema;\n  };\n\n  formatDescription = (description, inline) => {\n    if (!description) return \"\";\n\n    const hasMultipleLines = description.includes(\"\\n\");\n\n    if (!hasMultipleLines) return description;\n\n    if (inline) {\n      return (\n        lodash\n          // @ts-expect-error TS(2339) FIXME: Property '_' does not exist on type 'LoDashStatic'... Remove this comment to see the full error message\n          ._(description)\n          .split(/\\n/g)\n          .map((part) => part.trim())\n          .compact()\n          .join(\" \")\n          .valueOf()\n      );\n    }\n\n    return description.replace(/\\n$/g, \"\");\n  };\n\n  formatObjectContent = (content) => {\n    const fields = [];\n\n    for (const part of content) {\n      const extraSpace = \"  \";\n      const result = `${extraSpace}${part.field},\\n`;\n\n      const renderedJsDoc = this.templatesWorker.renderTemplate(\n        this.config.templatesToRender.dataContractJsDoc,\n        {\n          data: part,\n        },\n      );\n\n      const routeNameFromTemplate = renderedJsDoc\n        .split(\"\\n\")\n        .map((c) => `${extraSpace}${c}`)\n        .join(\"\\n\");\n\n      if (routeNameFromTemplate) {\n        fields.push(`${routeNameFromTemplate}${result}`);\n      } else {\n        fields.push(`${result}`);\n      }\n    }\n\n    return fields.join(\"\");\n  };\n}\n","export const sortByProperty =\n  (propertyName: string) =>\n  (o1: Record<string, any>, o2: Record<string, any>): 1 | -1 | 0 => {\n    if (o1[propertyName] > o2[propertyName]) {\n      return 1;\n    }\n    if (o1[propertyName] < o2[propertyName]) {\n      return -1;\n    }\n    return 0;\n  };\n","import type { CodeGenConfig } from \"../configuration.js\";\nimport type { SchemaComponentsMap } from \"../schema-components-map.js\";\nimport type { TypeNameFormatter } from \"../type-name-formatter.js\";\nimport type { SchemaFormatters } from \"./schema-formatters.js\";\nimport type { SchemaParser } from \"./schema-parser.js\";\nimport type { SchemaParserFabric } from \"./schema-parser-fabric.js\";\nimport type { SchemaUtils } from \"./schema-utils.js\";\n\nexport class MonoSchemaParser {\n  schema;\n  typeName;\n  schemaPath;\n\n  schemaParser: SchemaParser;\n  schemaParserFabric: SchemaParserFabric;\n  typeNameFormatter: TypeNameFormatter;\n  schemaComponentsMap: SchemaComponentsMap;\n  schemaUtils: SchemaUtils;\n  config: CodeGenConfig;\n  schemaFormatters: SchemaFormatters;\n\n  constructor(\n    schemaParser: SchemaParser,\n    schema,\n    typeName = null,\n    schemaPath = [],\n  ) {\n    this.schemaParser = schemaParser;\n    this.schemaParserFabric = schemaParser.schemaParserFabric;\n    this.schema = schema;\n    this.typeName = typeName;\n    this.typeNameFormatter = schemaParser.typeNameFormatter;\n    this.schemaPath = schemaPath;\n    this.schemaComponentsMap = this.schemaParser.schemaComponentsMap;\n    this.schemaUtils = this.schemaParser.schemaUtils;\n    this.config = this.schemaParser.config;\n    this.schemaFormatters = this.schemaParser.schemaFormatters;\n  }\n\n  parse() {\n    throw new Error(\"not implemented\");\n  }\n\n  buildTypeNameFromPath = () => {\n    return this.schemaUtils.buildTypeNameFromPath(this.schemaPath);\n  };\n}\n","import { SCHEMA_TYPES } from \"../../constants.js\";\nimport { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\nexport class ArraySchemaParser extends MonoSchemaParser {\n  override parse() {\n    let contentType;\n    const { type, description, items } = this.schema || {};\n\n    if (Array.isArray(items) && type === SCHEMA_TYPES.ARRAY) {\n      const tupleContent = [];\n      for (const item of items) {\n        tupleContent.push(\n          this.schemaParserFabric\n            .createSchemaParser({ schema: item, schemaPath: this.schemaPath })\n            .getInlineParseContent(),\n        );\n      }\n      contentType = this.config.Ts.Tuple(tupleContent);\n    } else {\n      const content = this.schemaParserFabric\n        .createSchemaParser({ schema: items, schemaPath: this.schemaPath })\n        .getInlineParseContent();\n      contentType = this.config.Ts.ArrayType(content);\n    }\n\n    return {\n      ...(typeof this.schema === \"object\" ? this.schema : {}),\n      $schemaPath: this.schemaPath.slice(),\n      $parsedSchema: true,\n      schemaType: SCHEMA_TYPES.PRIMITIVE,\n      type: SCHEMA_TYPES.PRIMITIVE,\n      typeIdentifier: this.config.Ts.Keyword.Type,\n      name: this.typeName,\n      description: this.schemaFormatters.formatDescription(description),\n      content: this.schemaUtils.safeAddNullToType(this.schema, contentType),\n    };\n  }\n}\n","import lodash from \"lodash\";\nimport { SCHEMA_TYPES } from \"../../constants.js\";\nimport { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\nexport class ComplexSchemaParser extends MonoSchemaParser {\n  override parse() {\n    const complexType = this.schemaUtils.getComplexType(this.schema);\n    const simpleSchema = lodash.omit(\n      lodash.clone(this.schema),\n      lodash.keys(this.schemaParser._complexSchemaParsers),\n    );\n    const complexSchemaContent = this.schemaParser._complexSchemaParsers[\n      complexType\n    ](this.schema);\n\n    return {\n      ...(typeof this.schema === \"object\" ? this.schema : {}),\n      $schemaPath: this.schemaPath.slice(),\n      $parsedSchema: true,\n      schemaType: SCHEMA_TYPES.COMPLEX,\n      type: SCHEMA_TYPES.PRIMITIVE,\n      typeIdentifier: this.config.Ts.Keyword.Type,\n      name: this.typeName,\n      description: this.schemaFormatters.formatDescription(\n        this.schema.description ||\n          lodash.compact(\n            lodash.map(this.schema[complexType], \"description\"),\n          )[0] ||\n          \"\",\n      ),\n      content:\n        this.config.Ts.IntersectionType(\n          lodash.compact([\n            this.config.Ts.ExpressionGroup(complexSchemaContent),\n            this.schemaUtils.getInternalSchemaType(simpleSchema) ===\n              SCHEMA_TYPES.OBJECT &&\n              this.config.Ts.ExpressionGroup(\n                this.schemaParserFabric\n                  .createSchemaParser({\n                    schema: simpleSchema,\n                    schemaPath: this.schemaPath,\n                  })\n                  .getInlineParseContent(),\n              ),\n          ]),\n        ) || this.config.Ts.Keyword.Any,\n    };\n  }\n}\n","import lodash from \"lodash\";\nimport { SCHEMA_TYPES } from \"../../constants.js\";\nimport { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\nexport class DiscriminatorSchemaParser extends MonoSchemaParser {\n  override parse() {\n    const ts = this.config.Ts;\n    const { discriminator, ...noDiscriminatorSchema } = this.schema;\n\n    if (!discriminator.mapping) {\n      return this.schemaParserFabric\n        .createSchemaParser({\n          schema: noDiscriminatorSchema,\n          typeName: this.typeName,\n          schemaPath: this.schemaPath,\n        })\n        .parseSchema();\n    }\n\n    // https://github.com/acacode/swagger-typescript-api/issues/456\n    // const skipMappingType = !!noDiscriminatorSchema.oneOf;\n    const skipMappingType = false;\n\n    const abstractSchemaStruct = this.createAbstractSchemaStruct();\n    // const complexSchemaStruct = this.createComplexSchemaStruct();\n    const discriminatorSchemaStruct = this.createDiscriminatorSchema({\n      skipMappingType,\n      abstractSchemaStruct,\n    });\n\n    const schemaContent = ts.IntersectionType(\n      [\n        abstractSchemaStruct?.content,\n        discriminatorSchemaStruct?.content,\n      ].filter(Boolean),\n    );\n\n    return {\n      ...(typeof this.schema === \"object\" ? this.schema : {}),\n      $schemaPath: this.schemaPath.slice(),\n      $parsedSchema: true,\n      schemaType: SCHEMA_TYPES.COMPLEX,\n      type: SCHEMA_TYPES.PRIMITIVE,\n      typeIdentifier: ts.Keyword.Type,\n      name: this.typeName,\n      description: this.schemaFormatters.formatDescription(\n        this.schema.description,\n      ),\n      content: schemaContent,\n    };\n  }\n\n  createDiscriminatorSchema = ({ skipMappingType, abstractSchemaStruct }) => {\n    const ts = this.config.Ts;\n\n    const refPath = this.schemaComponentsMap.createRef([\n      \"components\",\n      \"schemas\",\n      this.typeName,\n    ]);\n    const { discriminator } = this.schema;\n    const mappingEntries = lodash.entries(discriminator.mapping);\n    const ableToCreateMappingType =\n      !skipMappingType &&\n      !!(abstractSchemaStruct?.typeName && mappingEntries.length);\n    const mappingContents = [];\n    let mappingTypeName;\n\n    /** { mapping_key: SchemaEnum.MappingKey, ... } */\n    const mappingPropertySchemaEnumKeysMap =\n      this.createMappingPropertySchemaEnumKeys({\n        abstractSchemaStruct,\n        discPropertyName: discriminator.propertyName,\n      });\n\n    if (ableToCreateMappingType) {\n      const rawTypeName = `${abstractSchemaStruct.typeName}_${discriminator.propertyName}`;\n      const generatedTypeName = this.schemaUtils.resolveTypeName(rawTypeName, {\n        suffixes: this.config.extractingOptions.discriminatorMappingSuffix,\n        resolver:\n          this.config.extractingOptions.discriminatorMappingNameResolver,\n      });\n\n      const content = ts.IntersectionType([\n        ts.ObjectWrapper(\n          ts.TypeField({\n            key: ts.StringValue(discriminator.propertyName),\n            value: \"Key\",\n          }),\n        ),\n        \"Type\",\n      ]);\n\n      const component = this.schemaParserFabric.createParsedComponent({\n        typeName: generatedTypeName,\n        schema: {\n          type: \"object\",\n          properties: {},\n          genericArgs: [{ name: \"Key\" }, { name: \"Type\" }],\n          internal: true,\n        },\n      });\n\n      component.typeData.content = content;\n\n      mappingTypeName = this.typeNameFormatter.format(component.typeName);\n    }\n\n    /** returns (GenericType<\"mapping_key\", MappingType>) or ({ discriminatorProperty: \"mapping_key\" } & MappingType) */\n    const createMappingContent = (mappingSchema, mappingKey) => {\n      const content = this.schemaParserFabric\n        .createSchemaParser({\n          schema: mappingSchema,\n          schemaPath: this.schemaPath,\n        })\n        .getInlineParseContent();\n\n      const mappingUsageKey =\n        mappingPropertySchemaEnumKeysMap[mappingKey] ||\n        ts.StringValue(mappingKey);\n\n      if (ableToCreateMappingType) {\n        return ts.TypeWithGeneric(mappingTypeName, [mappingUsageKey, content]);\n      }\n\n      return ts.ExpressionGroup(\n        ts.IntersectionType([\n          ts.ObjectWrapper(\n            ts.TypeField({\n              key: discriminator.propertyName,\n              value: mappingUsageKey,\n            }),\n          ),\n          content,\n        ]),\n      );\n    };\n\n    for (const [mappingKey, schema] of mappingEntries) {\n      const mappingSchema =\n        typeof schema === \"string\" ? { $ref: schema } : schema;\n\n      this.mutateMappingDependentSchema({\n        discPropertyName: discriminator.propertyName,\n        abstractSchemaStruct,\n        mappingSchema,\n        refPath,\n        mappingPropertySchemaEnumKeysMap,\n      });\n\n      mappingContents.push(createMappingContent(mappingSchema, mappingKey));\n    }\n\n    if (skipMappingType) return null;\n\n    const content = ts.ExpressionGroup(ts.UnionType(mappingContents));\n\n    return {\n      content,\n    };\n  };\n\n  createMappingPropertySchemaEnumKeys = ({\n    abstractSchemaStruct,\n    discPropertyName,\n  }) => {\n    const ts = this.config.Ts;\n\n    let mappingPropertySchemaEnumKeysMap = {};\n    let mappingPropertySchema = lodash.get(\n      abstractSchemaStruct?.component?.rawTypeData,\n      [\"properties\", discPropertyName],\n    );\n    if (this.schemaUtils.isRefSchema(mappingPropertySchema)) {\n      mappingPropertySchema = this.schemaUtils.getSchemaRefType(\n        mappingPropertySchema,\n      );\n    }\n\n    if (\n      mappingPropertySchema?.rawTypeData?.$parsed?.type === SCHEMA_TYPES.ENUM\n    ) {\n      mappingPropertySchemaEnumKeysMap = lodash.reduce(\n        mappingPropertySchema.rawTypeData.$parsed.enum,\n        (acc, key, index) => {\n          const enumKey =\n            mappingPropertySchema.rawTypeData.$parsed.content[index].key;\n          acc[key] = ts.EnumUsageKey(\n            mappingPropertySchema.rawTypeData.$parsed.typeName,\n            enumKey,\n          );\n          return acc;\n        },\n        {},\n      );\n    }\n\n    return mappingPropertySchemaEnumKeysMap;\n  };\n\n  mutateMappingDependentSchema = ({\n    discPropertyName,\n    abstractSchemaStruct,\n    mappingSchema,\n    refPath,\n    mappingPropertySchemaEnumKeysMap,\n  }) => {\n    const complexSchemaKeys = lodash.keys(\n      this.schemaParser._complexSchemaParsers,\n    );\n    // override parent dependencies\n    if (mappingSchema.$ref && abstractSchemaStruct?.component?.$ref) {\n      const mappingRefSchema =\n        this.schemaUtils.getSchemaRefType(mappingSchema)?.rawTypeData;\n      if (mappingRefSchema) {\n        for (const schemaKey of complexSchemaKeys) {\n          if (Array.isArray(mappingRefSchema[schemaKey])) {\n            mappingRefSchema[schemaKey] = mappingRefSchema[schemaKey].map(\n              (schema) => {\n                if (schema.$ref === refPath) {\n                  return {\n                    ...schema,\n                    $ref: abstractSchemaStruct.component.$ref,\n                  };\n                }\n                if (\n                  this.schemaUtils.getInternalSchemaType(schema) ===\n                  SCHEMA_TYPES.OBJECT\n                ) {\n                  for (const schemaPropertyName in schema.properties) {\n                    const schemaProperty =\n                      schema.properties[schemaPropertyName];\n                    if (\n                      schemaPropertyName === discPropertyName &&\n                      this.schemaUtils.getInternalSchemaType(schemaProperty) ===\n                        SCHEMA_TYPES.ENUM &&\n                      schemaProperty.enum.length === 1 &&\n                      mappingPropertySchemaEnumKeysMap[schemaProperty.enum[0]]\n                    ) {\n                      schema.properties[schemaPropertyName] =\n                        this.schemaParserFabric.createSchema({\n                          content:\n                            mappingPropertySchemaEnumKeysMap[\n                              schemaProperty.enum[0]\n                            ],\n                        });\n                    }\n                  }\n                }\n                return schema;\n              },\n            );\n          }\n        }\n      }\n    }\n  };\n\n  createAbstractSchemaStruct = () => {\n    const { discriminator, ...noDiscriminatorSchema } = this.schema;\n    const complexSchemaKeys = lodash.keys(\n      this.schemaParser._complexSchemaParsers,\n    );\n    const schema = lodash.omit(\n      structuredClone(noDiscriminatorSchema),\n      complexSchemaKeys,\n    );\n    const schemaIsAny =\n      this.schemaParserFabric.getInlineParseContent(structuredClone(schema)) ===\n      this.config.Ts.Keyword.Any;\n    const schemaIsEmpty = !lodash.keys(schema).length;\n\n    if (schemaIsEmpty || schemaIsAny) return null;\n\n    const typeName = this.schemaUtils.resolveTypeName(this.typeName, {\n      prefixes: this.config.extractingOptions.discriminatorAbstractPrefix,\n      resolver: this.config.extractingOptions.discriminatorAbstractResolver,\n    });\n    const component = this.schemaComponentsMap.createComponent(\n      this.schemaComponentsMap.createRef([\"components\", \"schemas\", typeName]),\n      {\n        ...schema,\n        internal: true,\n      },\n    );\n    const content = this.schemaParserFabric\n      .createSchemaParser({ schema: component, schemaPath: this.schemaPath })\n      .getInlineParseContent();\n\n    return {\n      typeName,\n      component,\n      content,\n    };\n  };\n\n  createComplexSchemaStruct = () => {\n    const ts = this.config.Ts;\n    const complexType = this.schemaUtils.getComplexType(this.schema);\n\n    if (complexType === SCHEMA_TYPES.COMPLEX_UNKNOWN) return null;\n\n    return {\n      content: ts.ExpressionGroup(\n        this.schemaParser._complexSchemaParsers[complexType](this.schema),\n      ),\n    };\n  };\n}\n","import { consola } from \"consola\";\nimport type { CodeGenConfig } from \"../../configuration.js\";\nimport { NameResolver } from \"../../util/name-resolver.js\";\n\nexport class EnumKeyResolver extends NameResolver {\n  counter = 1;\n  constructor(config: CodeGenConfig, reservedNames: string[]) {\n    super(config, reservedNames, (variants) => {\n      const generatedVariant =\n        (variants[0] && `${variants[0]}${this.counter++}`) ||\n        `${this.config.enumKeyResolverName}${this.counter++}`;\n      consola.debug(\n        \"generated fallback type name for enum key - \",\n        generatedVariant,\n      );\n      return generatedVariant;\n    });\n  }\n}\n","import lodash from \"lodash\";\nimport { SCHEMA_TYPES } from \"../../constants.js\";\nimport { MonoSchemaParser } from \"../mono-schema-parser.js\";\nimport { EnumKeyResolver } from \"../util/enum-key-resolver.js\";\n\nexport class EnumSchemaParser extends MonoSchemaParser {\n  enumKeyResolver: EnumKeyResolver;\n\n  constructor(...args) {\n    // @ts-expect-error TS(2556) FIXME: A spread argument must either have a tuple type or... Remove this comment to see the full error message\n    super(...args);\n    this.enumKeyResolver = new EnumKeyResolver(this.config, []);\n  }\n\n  extractEnum = (pathTypeName) => {\n    const generatedTypeName = this.schemaUtils.resolveTypeName(pathTypeName, {\n      suffixes: this.config.extractingOptions.enumSuffix,\n      resolver: this.config.extractingOptions.enumNameResolver,\n    });\n    const customComponent = this.schemaComponentsMap.createComponent(\n      this.schemaComponentsMap.createRef([\n        \"components\",\n        \"schemas\",\n        generatedTypeName,\n      ]),\n      {\n        ...this.schema,\n      },\n    );\n    return this.schemaParserFabric.parseSchema(customComponent);\n  };\n\n  override parse() {\n    const pathTypeName = this.buildTypeNameFromPath();\n\n    if (this.config.extractEnums && !this.typeName && pathTypeName != null) {\n      return this.extractEnum(pathTypeName);\n    }\n\n    const refType = this.schemaUtils.getSchemaRefType(this.schema);\n    const $ref = refType?.$ref || null;\n\n    // fix schema when enum has length 1+ but value is []\n    if (Array.isArray(this.schema.enum)) {\n      this.schema.enum = this.schema.enum.filter((key) => key != null);\n    }\n\n    if (Array.isArray(this.schema.enum) && Array.isArray(this.schema.enum[0])) {\n      return this.schemaParserFabric.parseSchema(\n        {\n          oneOf: this.schema.enum.map((enumNames) => ({\n            type: \"array\",\n            items: enumNames.map((enumName) => ({\n              type: \"string\",\n              enum: [enumName],\n            })),\n          })),\n        },\n        this.typeName,\n        this.schemaPath,\n      );\n    }\n\n    const keyType = this.schemaUtils.getSchemaType(this.schema);\n    const enumNames = this.schemaUtils.getEnumNames(this.schema);\n    const enumDescriptions = this.schemaUtils.getEnumDescriptions(this.schema);\n\n    let content = null;\n\n    const formatValue = (value) => {\n      if (value === null) {\n        return this.config.Ts.NullValue(value);\n      }\n      if (\n        keyType.includes(this.schemaUtils.getSchemaType({ type: \"number\" }))\n      ) {\n        return this.config.Ts.NumberValue(value);\n      }\n      if (\n        keyType.includes(this.schemaUtils.getSchemaType({ type: \"boolean\" }))\n      ) {\n        return this.config.Ts.BooleanValue(value);\n      }\n\n      return this.config.Ts.StringValue(value);\n    };\n\n    if (Array.isArray(enumNames) && lodash.size(enumNames)) {\n      content = enumNames.map((enumName, index) => {\n        const enumValue = lodash.get(this.schema.enum, index);\n        const formattedKey = this.formatEnumKey({\n          key: enumName,\n          value: enumValue,\n        });\n\n        if (this.config.enumNamesAsValues || enumValue === undefined) {\n          return {\n            key: formattedKey,\n            type: this.config.Ts.Keyword.String,\n            value: this.config.Ts.StringValue(enumName),\n            description: enumDescriptions?.[index],\n          };\n        }\n\n        return {\n          key: formattedKey,\n          type: keyType,\n          value: formatValue(enumValue),\n          description: enumDescriptions?.[index],\n        };\n      });\n    } else {\n      content = this.schema.enum.map((value, index) => {\n        return {\n          // @ts-expect-error TS(2345) FIXME: Argument of type '{ value: any; }' is not assignab... Remove this comment to see the full error message\n          key: this.formatEnumKey({ value }),\n          type: keyType,\n          value: formatValue(value),\n          description: enumDescriptions?.[index],\n        };\n      });\n    }\n\n    return {\n      ...(typeof this.schema === \"object\" ? this.schema : {}),\n      $ref: $ref,\n      typeName: this.typeName || ($ref && refType.typeName) || null,\n      $parsedSchema: true,\n      schemaType: SCHEMA_TYPES.ENUM,\n      type: SCHEMA_TYPES.ENUM,\n      keyType: keyType,\n      typeIdentifier: this.config.generateUnionEnums\n        ? this.config.Ts.Keyword.Type\n        : this.config.Ts.Keyword.Enum,\n      name: this.typeName,\n      description: this.schemaFormatters.formatDescription(\n        this.schema.description,\n      ),\n      content,\n    };\n  }\n\n  formatEnumKey = ({ key, value }) => {\n    let formatted;\n\n    if (key) {\n      formatted = this.typeNameFormatter.format(key, {\n        type: \"enum-key\",\n      });\n    }\n\n    if (!formatted) {\n      formatted = this.typeNameFormatter.format(`${value}`, {\n        type: \"enum-key\",\n      });\n    }\n\n    return this.enumKeyResolver.resolve([formatted]);\n  };\n}\n","import lodash from \"lodash\";\nimport { SCHEMA_TYPES } from \"../../constants.js\";\nimport { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\nexport class ObjectSchemaParser extends MonoSchemaParser {\n  override parse() {\n    const contentProperties = this.getObjectSchemaContent(this.schema);\n\n    return {\n      ...(typeof this.schema === \"object\" ? this.schema : {}),\n      $schemaPath: this.schemaPath.slice(),\n      $parsedSchema: true,\n      schemaType: SCHEMA_TYPES.OBJECT,\n      type: SCHEMA_TYPES.OBJECT,\n      typeIdentifier: this.config.Ts.Keyword.Interface,\n      name: this.typeName,\n      description: this.schemaFormatters.formatDescription(\n        this.schema.description,\n      ),\n      allFieldsAreOptional: !contentProperties.some((part) => part.isRequired),\n      content: contentProperties,\n    };\n  }\n\n  getObjectSchemaContent = (schema) => {\n    const { properties, additionalProperties } = schema || {};\n\n    const propertiesContent = lodash.map(properties, (property, name) => {\n      const required = this.schemaUtils.isPropertyRequired(\n        name,\n        property,\n        schema,\n      );\n      const rawTypeData = lodash.get(\n        this.schemaUtils.getSchemaRefType(property),\n        \"rawTypeData\",\n        {},\n      );\n      const nullable = !!(rawTypeData.nullable || property.nullable);\n      const fieldName = this.typeNameFormatter.isValidName(name)\n        ? name\n        : this.config.Ts.StringValue(name);\n      const fieldValue = this.schemaParserFabric\n        .createSchemaParser({\n          schema: property,\n          schemaPath: [...this.schemaPath, name],\n        })\n        .getInlineParseContent();\n      const readOnly = property.readOnly;\n\n      return {\n        ...property,\n        $$raw: property,\n        title: property.title,\n        description:\n          property.description ||\n          lodash.compact(\n            lodash.map(\n              property[this.schemaUtils.getComplexType(property)],\n              \"description\",\n            ),\n          )[0] ||\n          rawTypeData.description ||\n          lodash.compact(\n            lodash.map(\n              rawTypeData[this.schemaUtils.getComplexType(rawTypeData)],\n              \"description\",\n            ),\n          )[0] ||\n          \"\",\n        isRequired: required,\n        isNullable: nullable,\n        name: fieldName,\n        value: fieldValue,\n        field: this.config.Ts.TypeField({\n          readonly: readOnly && this.config.addReadonly,\n          optional: !required,\n          key: fieldName,\n          value: fieldValue,\n        }),\n      };\n    });\n\n    if (additionalProperties) {\n      const propertyNamesSchema =\n        this.schemaUtils.getSchemaPropertyNamesSchema(schema);\n      let interfaceKeysContent: any;\n\n      if (propertyNamesSchema) {\n        interfaceKeysContent = this.schemaParserFabric\n          .createSchemaParser({\n            schema: propertyNamesSchema,\n            schemaPath: this.schemaPath,\n          })\n          .getInlineParseContent();\n      } else {\n        interfaceKeysContent = this.config.Ts.Keyword.String;\n      }\n\n      propertiesContent.push({\n        $$raw: { additionalProperties },\n        description: \"\",\n        isRequired: false,\n        field: this.config.Ts.InterfaceDynamicField(\n          interfaceKeysContent,\n          this.config.Ts.Keyword.Any,\n        ),\n      });\n    }\n\n    return propertiesContent;\n  };\n}\n","import { SCHEMA_TYPES } from \"../../constants.js\";\nimport { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\nexport class PrimitiveSchemaParser extends MonoSchemaParser {\n  override parse() {\n    let contentType = null;\n    const { additionalProperties, type, description, items } =\n      this.schema || {};\n\n    if (type === this.config.Ts.Keyword.Object && additionalProperties) {\n      const propertyNamesSchema = this.schemaUtils.getSchemaPropertyNamesSchema(\n        this.schema,\n      );\n\n      let recordKeysContent: any;\n      let recordValuesContent: any;\n\n      if (propertyNamesSchema) {\n        recordKeysContent = this.schemaParserFabric\n          .createSchemaParser({\n            schema: propertyNamesSchema,\n            schemaPath: this.schemaPath,\n          })\n          .getInlineParseContent();\n      } else {\n        recordKeysContent = this.config.Ts.Keyword.String;\n      }\n\n      if (typeof additionalProperties === \"object\") {\n        recordValuesContent = this.schemaParserFabric\n          .createSchemaParser({\n            schema: additionalProperties,\n            schemaPath: this.schemaPath,\n          })\n          .getInlineParseContent();\n      } else {\n        recordValuesContent = this.config.Ts.Keyword.Any;\n      }\n\n      contentType = this.config.Ts.RecordType(\n        recordKeysContent,\n        recordValuesContent,\n      );\n    }\n\n    if (Array.isArray(type) && type.length) {\n      contentType = this.schemaParser._complexSchemaParsers.oneOf({\n        ...(typeof this.schema === \"object\" ? this.schema : {}),\n        oneOf: type.map((type) => ({ type })),\n      });\n    }\n\n    if (Array.isArray(items) && type === SCHEMA_TYPES.ARRAY) {\n      contentType = this.config.Ts.Tuple(\n        items.map((item) =>\n          this.schemaParserFabric\n            .createSchemaParser({ schema: item, schemaPath: this.schemaPath })\n            .getInlineParseContent(),\n        ),\n      );\n    }\n\n    return {\n      ...(typeof this.schema === \"object\" ? this.schema : {}),\n      $schemaPath: this.schemaPath.slice(),\n      $parsedSchema: true,\n      schemaType: SCHEMA_TYPES.PRIMITIVE,\n      type: SCHEMA_TYPES.PRIMITIVE,\n      typeIdentifier: this.config.Ts.Keyword.Type,\n      name: this.typeName,\n      description: this.schemaFormatters.formatDescription(description),\n      // TODO: probably it should be refactored. `type === 'null'` is not flexible\n      content:\n        type === this.config.Ts.Keyword.Null\n          ? type\n          : contentType || this.schemaUtils.getSchemaType(this.schema),\n    };\n  }\n}\n","import { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\n// T1 & T2\nexport class AllOfSchemaParser extends MonoSchemaParser {\n  override parse() {\n    const ignoreTypes = [this.config.Ts.Keyword.Any];\n    const combined = this.schema.allOf.map((childSchema) =>\n      this.schemaParserFabric.getInlineParseContent(\n        this.schemaUtils.makeAddRequiredToChildSchema(this.schema, childSchema),\n        null,\n        this.schemaPath,\n      ),\n    );\n    const filtered = this.schemaUtils.filterSchemaContents(\n      combined,\n      (content) => !ignoreTypes.includes(content),\n    );\n\n    const type = this.config.Ts.IntersectionType(filtered);\n\n    return this.schemaUtils.safeAddNullToType(this.schema, type);\n  }\n}\n","import { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\n// T1 | T2\nexport class AnyOfSchemaParser extends MonoSchemaParser {\n  override parse() {\n    const ignoreTypes = [this.config.Ts.Keyword.Any];\n    const combined = this.schema.anyOf.map((childSchema) =>\n      this.schemaParserFabric.getInlineParseContent(\n        this.schemaUtils.makeAddRequiredToChildSchema(this.schema, childSchema),\n        null,\n        this.schemaPath,\n      ),\n    );\n\n    const filtered = this.schemaUtils.filterSchemaContents(\n      combined,\n      (content) => !ignoreTypes.includes(content),\n    );\n\n    const type = this.config.Ts.UnionType(filtered);\n\n    return this.schemaUtils.safeAddNullToType(this.schema, type);\n  }\n}\n","import { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\nexport class NotSchemaParser extends MonoSchemaParser {\n  override parse() {\n    return this.config.Ts.Keyword.Any;\n  }\n}\n","import { MonoSchemaParser } from \"../mono-schema-parser.js\";\n\n// T1 | T2\nexport class OneOfSchemaParser extends MonoSchemaParser {\n  override parse() {\n    const ignoreTypes = [this.config.Ts.Keyword.Any];\n    const combined = this.schema.oneOf.map((childSchema) =>\n      this.schemaParserFabric.getInlineParseContent(\n        this.schemaUtils.makeAddRequiredToChildSchema(this.schema, childSchema),\n        null,\n        this.schemaPath,\n      ),\n    );\n\n    const filtered = this.schemaUtils.filterSchemaContents(\n      combined,\n      (content) => !ignoreTypes.includes(content),\n    );\n\n    const type = this.config.Ts.UnionType(filtered);\n\n    return this.schemaUtils.safeAddNullToType(this.schema, type);\n  }\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport type { CodeGenConfig } from \"../configuration.js\";\nimport { SCHEMA_TYPES } from \"../constants.js\";\nimport type { SchemaComponentsMap } from \"../schema-components-map.js\";\nimport type { SchemaWalker } from \"../schema-walker.js\";\nimport type { TemplatesWorker } from \"../templates-worker.js\";\nimport type { TypeNameFormatter } from \"../type-name-formatter.js\";\nimport { sortByProperty } from \"../util/sort-by-property.js\";\nimport { ArraySchemaParser } from \"./base-schema-parsers/array.js\";\nimport { ComplexSchemaParser } from \"./base-schema-parsers/complex.js\";\nimport { DiscriminatorSchemaParser } from \"./base-schema-parsers/discriminator.js\";\nimport { EnumSchemaParser } from \"./base-schema-parsers/enum.js\";\nimport { ObjectSchemaParser } from \"./base-schema-parsers/object.js\";\nimport { PrimitiveSchemaParser } from \"./base-schema-parsers/primitive.js\";\nimport { AllOfSchemaParser } from \"./complex-schema-parsers/all-of.js\";\nimport { AnyOfSchemaParser } from \"./complex-schema-parsers/any-of.js\";\nimport { NotSchemaParser } from \"./complex-schema-parsers/not.js\";\nimport { OneOfSchemaParser } from \"./complex-schema-parsers/one-of.js\";\nimport type { SchemaFormatters } from \"./schema-formatters.js\";\nimport type { SchemaParserFabric } from \"./schema-parser-fabric.js\";\nimport type { SchemaUtils } from \"./schema-utils.js\";\n\nexport class SchemaParser {\n  schemaParserFabric: SchemaParserFabric;\n  config: CodeGenConfig;\n  schemaComponentsMap: SchemaComponentsMap;\n  typeNameFormatter: TypeNameFormatter;\n  schemaFormatters: SchemaFormatters;\n  schemaUtils: SchemaUtils;\n  templatesWorker: TemplatesWorker;\n  schemaWalker: SchemaWalker;\n\n  typeName;\n  schema;\n  schemaPath = [];\n\n  // @ts-expect-error TS(2525) FIXME: Initializer provides no value for this binding ele... Remove this comment to see the full error message\n  constructor(schemaParserFabric, { typeName, schema, schemaPath } = {}) {\n    this.schemaParserFabric = schemaParserFabric;\n    this.config = schemaParserFabric.config;\n    this.templatesWorker = schemaParserFabric.templatesWorker;\n    this.schemaComponentsMap = schemaParserFabric.schemaComponentsMap;\n    this.typeNameFormatter = schemaParserFabric.typeNameFormatter;\n    this.schemaWalker = schemaParserFabric.schemaWalker;\n    this.schemaFormatters = schemaParserFabric.schemaFormatters;\n    this.schemaUtils = schemaParserFabric.schemaUtils;\n\n    this.typeName = typeName || null;\n    this.schema = schema;\n    this.schemaPath = [...(schemaPath || [])];\n  }\n\n  _complexSchemaParsers = {\n    [SCHEMA_TYPES.COMPLEX_ONE_OF]: (schema) => {\n      const SchemaParser =\n        this.config.schemaParsers.complexOneOf || OneOfSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        null,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.COMPLEX_ALL_OF]: (schema) => {\n      const SchemaParser =\n        this.config.schemaParsers.complexAllOf || AllOfSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        null,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.COMPLEX_ANY_OF]: (schema) => {\n      const SchemaParser =\n        this.config.schemaParsers.complexAnyOf || AnyOfSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        null,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.COMPLEX_NOT]: (schema) => {\n      const SchemaParser =\n        this.config.schemaParsers.complexNot || NotSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        null,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n  };\n\n  _baseSchemaParsers = {\n    [SCHEMA_TYPES.ENUM]: (schema, typeName) => {\n      const SchemaParser = this.config.schemaParsers.enum || EnumSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        typeName,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.OBJECT]: (schema, typeName) => {\n      const SchemaParser =\n        this.config.schemaParsers.object || ObjectSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        typeName,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.COMPLEX]: (schema, typeName) => {\n      const SchemaParser =\n        this.config.schemaParsers.complex || ComplexSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        typeName,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.PRIMITIVE]: (schema, typeName) => {\n      const SchemaParser =\n        this.config.schemaParsers.primitive || PrimitiveSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        typeName,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.DISCRIMINATOR]: (schema, typeName) => {\n      const SchemaParser =\n        this.config.schemaParsers.discriminator || DiscriminatorSchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        typeName,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n    [SCHEMA_TYPES.ARRAY]: (schema, typeName) => {\n      const SchemaParser = this.config.schemaParsers.array || ArraySchemaParser;\n      const schemaParser = new SchemaParser(\n        this,\n        schema,\n        typeName,\n        this.schemaPath,\n      );\n      return schemaParser.parse();\n    },\n  };\n\n  parseSchema = () => {\n    if (!this.schema)\n      return this._baseSchemaParsers[SCHEMA_TYPES.PRIMITIVE](\n        null,\n        this.typeName,\n      );\n\n    let schemaType = null;\n    let parsedSchema = null;\n\n    if (typeof this.schema === \"string\") {\n      return this.schema;\n    }\n\n    if (!this.schema.$parsed) {\n      if (!this.typeName && this.schemaUtils.isRefSchema(this.schema)) {\n        this.typeName = this.schemaUtils.getSchemaType(this.schema);\n      }\n\n      //#region swagger schemas fixes\n\n      // schema has items but don't have array type\n      if (\n        this.schema.items &&\n        !Array.isArray(this.schema.items) &&\n        !this.schema.type\n      ) {\n        this.schema.type = SCHEMA_TYPES.ARRAY;\n      }\n      // schema is enum with one null value\n      if (\n        Array.isArray(this.schema.enum) &&\n        this.schema.enum.length === 1 &&\n        this.schema.enum[0] == null\n      ) {\n        consola.debug(\"invalid enum schema\", this.schema);\n        this.schema = { type: this.config.Ts.Keyword.Null };\n      }\n      // schema is response schema\n      if (\"content\" in this.schema && typeof this.schema.content === \"object\") {\n        const schema = this.extractSchemaFromResponseStruct(this.schema);\n        const schemaParser = this.schemaParserFabric.createSchemaParser({\n          schema,\n          typeName: this.typeName,\n          schemaPath: this.schemaPath,\n        });\n        this.schema.$parsed = schemaParser.parseSchema();\n        return this.schema.$parsed;\n      }\n\n      //#endregion\n\n      schemaType = this.schemaUtils.getInternalSchemaType(this.schema);\n\n      this.schemaPath.push(this.typeName);\n\n      lodash.merge(\n        this.schema,\n        this.config.hooks.onPreParseSchema(\n          this.schema,\n          this.typeName,\n          schemaType,\n        ),\n      );\n      parsedSchema = this._baseSchemaParsers[schemaType](\n        this.schema,\n        this.typeName,\n      );\n      this.schema.$parsed =\n        this.config.hooks.onParseSchema(this.schema, parsedSchema) ||\n        parsedSchema;\n\n      if (\n        this.config.sortTypes &&\n        Array.isArray(this.schema.$parsed?.content)\n      ) {\n        this.schema.$parsed.content = this.schema.$parsed.content.sort(\n          sortByProperty(\"name\"),\n        );\n      }\n    }\n\n    this.schemaPath.pop();\n\n    return this.schema.$parsed;\n  };\n\n  getInlineParseContent = () => {\n    const parsedSchema = this.parseSchema();\n    const formattedSchema = this.schemaFormatters.formatSchema(\n      parsedSchema,\n      \"inline\",\n    );\n    return formattedSchema.content;\n  };\n\n  getParseContent = () => {\n    const parsedSchema = this.parseSchema();\n    const formattedSchema = this.schemaFormatters.formatSchema(\n      parsedSchema,\n      \"base\",\n    );\n    return formattedSchema.content;\n  };\n\n  extractSchemaFromResponseStruct = (responseStruct) => {\n    const { content, ...extras } = responseStruct;\n\n    const firstResponse = lodash.first(lodash.values(content));\n    const firstSchema = lodash.get(firstResponse, \"schema\");\n\n    if (!firstSchema) return;\n\n    return {\n      ...extras,\n      ...lodash.omit(firstResponse, \"schema\"),\n      ...firstSchema,\n    };\n  };\n}\n","import lodash from \"lodash\";\n\nexport function internalCase(value: string) {\n  return lodash.camelCase(lodash.lowerCase(value));\n}\n","import lodash from \"lodash\";\n\nexport function pascalCase(value: string) {\n  return lodash.upperFirst(lodash.camelCase(value));\n}\n","import lodash from \"lodash\";\nimport type { CodeGenConfig } from \"../configuration.js\";\nimport { SCHEMA_TYPES } from \"../constants.js\";\nimport type { SchemaComponentsMap } from \"../schema-components-map.js\";\nimport type { SchemaWalker } from \"../schema-walker.js\";\nimport type { TypeNameFormatter } from \"../type-name-formatter.js\";\nimport { internalCase } from \"../util/internal-case.js\";\nimport { pascalCase } from \"../util/pascal-case.js\";\n\nexport class SchemaUtils {\n  config: CodeGenConfig;\n  schemaComponentsMap: SchemaComponentsMap;\n  typeNameFormatter: TypeNameFormatter;\n  schemaWalker: SchemaWalker;\n\n  constructor({\n    config,\n    schemaComponentsMap,\n    typeNameFormatter,\n    schemaWalker,\n  }) {\n    this.config = config;\n    this.schemaComponentsMap = schemaComponentsMap;\n    this.typeNameFormatter = typeNameFormatter;\n    this.schemaWalker = schemaWalker;\n  }\n\n  getRequiredProperties = (schema) => {\n    return lodash.uniq(\n      (schema && Array.isArray(schema.required) && schema.required) || [],\n    );\n  };\n\n  isRefSchema = (schema) => {\n    return !!schema?.$ref;\n  };\n\n  getEnumNames = (schema) => {\n    return (\n      schema[\"x-enumNames\"] ||\n      schema.xEnumNames ||\n      schema[\"x-enumnames\"] ||\n      schema[\"x-enum-varnames\"]\n    );\n  };\n\n  getEnumDescriptions = (schema) => {\n    return (\n      schema[\"x-enumDescriptions\"] ||\n      schema.xEnumDescriptions ||\n      schema[\"x-enumdescriptions\"] ||\n      schema[\"x-enum-descriptions\"]\n    );\n  };\n\n  getSchemaPropertyNamesSchema = (schema) => {\n    if (!schema) return null;\n    return schema.propertyNames || schema[\"x-propertyNames\"] || null;\n  };\n\n  getSchemaRefType = (schema) => {\n    if (!this.isRefSchema(schema)) return null;\n    return this.schemaComponentsMap.get(schema.$ref);\n  };\n\n  isPropertyRequired = (name, propertySchema, rootSchema) => {\n    if (propertySchema[\"x-omitempty\"] === false) {\n      return true;\n    }\n\n    const isRequired =\n      typeof propertySchema.required === \"boolean\"\n        ? !!propertySchema.required\n        : Array.isArray(rootSchema.required)\n          ? rootSchema.required.includes(name)\n          : !!rootSchema.required;\n\n    if (this.config.convertedFromSwagger2) {\n      return typeof propertySchema.nullable === this.config.Ts.Keyword.Undefined\n        ? isRequired\n        : !propertySchema.nullable;\n    }\n    return isRequired;\n  };\n\n  isNullMissingInType = (schema, type) => {\n    const { nullable, type: schemaType } = schema || {};\n    return (\n      (nullable ||\n        !!lodash.get(schema, \"x-nullable\") ||\n        schemaType === this.config.Ts.Keyword.Null) &&\n      typeof type === \"string\" &&\n      !type.includes(` ${this.config.Ts.Keyword.Null}`) &&\n      !type.includes(`${this.config.Ts.Keyword.Null} `)\n    );\n  };\n\n  safeAddNullToType = (schema, type) => {\n    if (this.isNullMissingInType(schema, type)) {\n      return this.config.Ts.UnionType([type, this.config.Ts.Keyword.Null]);\n    }\n    return type;\n  };\n\n  getSchemaPrimitiveType = (rawSchema) => {\n    const schema = rawSchema || {};\n\n    if (schema.type) {\n      return internalCase(schema.type);\n    }\n    if (schema.enum) {\n      const enumFieldType = typeof schema.enum[0];\n      if (enumFieldType === this.config.Ts.Keyword.Undefined) return;\n\n      return internalCase(enumFieldType);\n    }\n    if (lodash.keys(schema.properties).length) {\n      return SCHEMA_TYPES.OBJECT;\n    }\n    if (schema.items) {\n      return SCHEMA_TYPES.ARRAY;\n    }\n\n    return null;\n  };\n\n  checkAndAddRequiredKeys = (schema, resultType) => {\n    if (\"$$requiredKeys\" in schema && schema.$$requiredKeys.length) {\n      this.config.update({\n        internalTemplateOptions: {\n          addUtilRequiredKeysType: true,\n        },\n      });\n      return this.config.Ts.TypeWithGeneric(\n        this.config.Ts.CodeGenKeyword.UtilRequiredKeys,\n        [\n          resultType,\n          this.config.Ts.UnionType(\n            schema.$$requiredKeys.map(this.config.Ts.StringValue),\n          ),\n        ],\n      );\n    }\n\n    return resultType;\n  };\n\n  makeAddRequiredToChildSchema = (parentSchema, childSchema) => {\n    if (!childSchema) return childSchema;\n\n    const required = lodash.uniq([\n      ...this.getRequiredProperties(parentSchema),\n      ...this.getRequiredProperties(childSchema),\n    ]);\n\n    const refData = this.getSchemaRefType(childSchema);\n\n    if (refData) {\n      const refObjectProperties = lodash.keys(\n        refData.rawTypeData?.properties || {},\n      );\n      const existedRequiredKeys = refObjectProperties.filter((key) =>\n        required.includes(key),\n      );\n\n      if (!existedRequiredKeys.length) return childSchema;\n\n      return {\n        ...childSchema,\n        $$requiredKeys: existedRequiredKeys,\n      };\n    }\n\n    if (childSchema.properties) {\n      const childSchemaProperties = lodash.keys(childSchema.properties);\n      const existedRequiredKeys = childSchemaProperties.filter((key) =>\n        required.includes(key),\n      );\n\n      if (!existedRequiredKeys.length) return childSchema;\n\n      return {\n        required: lodash.uniq([\n          ...this.getRequiredProperties(childSchema),\n          ...existedRequiredKeys,\n        ]),\n        ...childSchema,\n      };\n    }\n\n    return childSchema;\n  };\n\n  filterSchemaContents = (contents, filterFn) => {\n    return lodash.uniq(contents.filter((type) => filterFn(type)));\n  };\n\n  resolveTypeName = (\n    typeName,\n    { suffixes, resolver, prefixes, shouldReserve = true },\n  ) => {\n    if (resolver) {\n      return this.config.componentTypeNameResolver.resolve([], (reserved) => {\n        return resolver(pascalCase(typeName), reserved);\n      });\n    }\n\n    return this.config.componentTypeNameResolver.resolve(\n      [\n        ...(prefixes || []).map((prefix) =>\n          pascalCase(`${prefix} ${typeName}`),\n        ),\n        ...(suffixes || []).map((suffix) =>\n          pascalCase(`${typeName} ${suffix}`),\n        ),\n      ],\n      shouldReserve,\n    );\n  };\n\n  getComplexType = (schema) => {\n    if (schema.oneOf) return SCHEMA_TYPES.COMPLEX_ONE_OF;\n    if (schema.allOf) return SCHEMA_TYPES.COMPLEX_ALL_OF;\n    if (schema.anyOf) return SCHEMA_TYPES.COMPLEX_ANY_OF;\n    // TODO :(\n    if (schema.not) return SCHEMA_TYPES.COMPLEX_NOT;\n\n    return SCHEMA_TYPES.COMPLEX_UNKNOWN;\n  };\n\n  getInternalSchemaType = (schema) => {\n    if (\n      !lodash.isEmpty(schema.enum) ||\n      !lodash.isEmpty(this.getEnumNames(schema))\n    ) {\n      return SCHEMA_TYPES.ENUM;\n    }\n    if (schema.discriminator) {\n      return SCHEMA_TYPES.DISCRIMINATOR;\n    }\n    if (schema.allOf || schema.oneOf || schema.anyOf || schema.not) {\n      return SCHEMA_TYPES.COMPLEX;\n    }\n    if (!lodash.isEmpty(schema.properties)) {\n      return SCHEMA_TYPES.OBJECT;\n    }\n    if (schema.type === SCHEMA_TYPES.ARRAY) {\n      return SCHEMA_TYPES.ARRAY;\n    }\n\n    return SCHEMA_TYPES.PRIMITIVE;\n  };\n\n  getSchemaType = (schema) => {\n    if (!schema) return this.config.Ts.Keyword.Any;\n\n    const refTypeInfo = this.getSchemaRefType(schema);\n\n    if (refTypeInfo) {\n      return this.checkAndAddRequiredKeys(\n        schema,\n        this.safeAddNullToType(\n          schema,\n          this.typeNameFormatter.format(refTypeInfo.typeName),\n        ),\n      );\n    }\n\n    let resultType;\n\n    if (this.isConstantSchema(schema)) {\n      resultType = this.formatJsValue(schema.const);\n    } else {\n      const primitiveType = this.getSchemaPrimitiveType(schema);\n\n      if (primitiveType == null) {\n        return this.config.Ts.Keyword.Any;\n      }\n\n      const typeAlias =\n        lodash.get(this.config.primitiveTypes, [\n          primitiveType,\n          schema.format,\n        ]) ||\n        lodash.get(this.config.primitiveTypes, [primitiveType, \"$default\"]) ||\n        this.config.primitiveTypes[primitiveType];\n\n      if (typeof typeAlias === \"function\") {\n        resultType = typeAlias(schema, this);\n      } else {\n        resultType = typeAlias || primitiveType;\n      }\n    }\n\n    if (!resultType) {\n      return this.config.Ts.Keyword.Any;\n    }\n\n    return this.checkAndAddRequiredKeys(\n      schema,\n      this.safeAddNullToType(schema, resultType),\n    );\n  };\n\n  buildTypeNameFromPath = (schemaPath) => {\n    schemaPath = lodash.uniq(lodash.compact(schemaPath));\n\n    if (!schemaPath || !schemaPath[0]) return null;\n\n    return pascalCase(\n      lodash.camelCase(\n        lodash\n          .uniq([schemaPath[0], schemaPath[schemaPath.length - 1]])\n          .join(\"_\"),\n      ),\n    );\n  };\n\n  isConstantSchema(schema) {\n    return \"const\" in schema;\n  }\n\n  formatJsValue = (value) => {\n    switch (typeof value) {\n      case \"string\": {\n        return this.config.Ts.StringValue(value);\n      }\n      case \"boolean\": {\n        return this.config.Ts.BooleanValue(value);\n      }\n      case \"number\": {\n        return this.config.Ts.NumberValue(value);\n      }\n      default: {\n        if (value === null) {\n          return this.config.Ts.NullValue(value);\n        }\n\n        return this.config.Ts.Keyword.Any;\n      }\n    }\n  };\n}\n","import type {\n  ParsedSchema,\n  SchemaComponent,\n  SchemaTypeEnumContent,\n  SchemaTypeObjectContent,\n  SchemaTypePrimitiveContent,\n} from \"../../types/index.js\";\nimport type { CodeGenConfig } from \"../configuration.js\";\nimport type { SchemaComponentsMap } from \"../schema-components-map.js\";\nimport type { SchemaWalker } from \"../schema-walker.js\";\nimport type { TemplatesWorker } from \"../templates-worker.js\";\nimport type { TypeNameFormatter } from \"../type-name-formatter.js\";\nimport { SchemaFormatters } from \"./schema-formatters.js\";\nimport { SchemaParser } from \"./schema-parser.js\";\nimport { SchemaUtils } from \"./schema-utils.js\";\n\nexport class SchemaParserFabric {\n  config: CodeGenConfig;\n  schemaComponentsMap: SchemaComponentsMap;\n  typeNameFormatter: TypeNameFormatter;\n  schemaFormatters: SchemaFormatters;\n  templatesWorker: TemplatesWorker;\n  schemaUtils: SchemaUtils;\n  schemaWalker: SchemaWalker;\n\n  constructor(\n    config: CodeGenConfig,\n    templatesWorker: TemplatesWorker,\n    schemaComponentsMap: SchemaComponentsMap,\n    typeNameFormatter: TypeNameFormatter,\n    schemaWalker: SchemaWalker,\n  ) {\n    this.config = config;\n    this.schemaComponentsMap = schemaComponentsMap;\n    this.typeNameFormatter = typeNameFormatter;\n    this.templatesWorker = templatesWorker;\n    this.schemaWalker = schemaWalker;\n    this.schemaUtils = new SchemaUtils(this);\n    this.schemaFormatters = new SchemaFormatters(this);\n  }\n\n  createSchemaParser = ({ schema, typeName, schemaPath }) => {\n    return new SchemaParser(this, { schema, typeName, schemaPath });\n  };\n\n  createSchema = ({\n    content,\n    linkedSchema = {},\n    linkedComponent,\n    schemaPath,\n    ...otherSchemaProps\n  }) => {\n    // @ts-expect-error TS(2345) FIXME: Argument of type '{ schema: any; schemaPath: any; ... Remove this comment to see the full error message\n    const parser = this.createSchemaParser({\n      schema: linkedComponent || linkedSchema,\n      schemaPath,\n    });\n    const parsed = parser.parseSchema();\n    parsed.content = content;\n    Object.assign(parsed, otherSchemaProps);\n    if (linkedComponent) {\n      linkedComponent.typeData = parsed;\n    }\n    return parser.schema;\n  };\n\n  createParsedComponent = ({\n    typeName,\n    schema,\n    schemaPath,\n  }): SchemaComponent => {\n    const schemaCopy = structuredClone(schema);\n    const customComponent = this.schemaComponentsMap.createComponent(\n      this.schemaComponentsMap.createRef([\"components\", \"schemas\", typeName]),\n      schemaCopy,\n    );\n    const parsed = this.parseSchema(schemaCopy, null, schemaPath);\n\n    parsed.name = typeName;\n    customComponent.typeData = parsed;\n\n    return customComponent;\n  };\n\n  parseSchema = (\n    schema: string,\n    typeName: string | null = null,\n    schemaPath: string[] = [],\n  ): ParsedSchema<\n    SchemaTypeObjectContent | SchemaTypeEnumContent | SchemaTypePrimitiveContent\n  > => {\n    const schemaParser = this.createSchemaParser({\n      schema,\n      typeName,\n      schemaPath,\n    });\n    return schemaParser.parseSchema();\n  };\n\n  getInlineParseContent = (\n    schema: string,\n    typeName: string | null,\n    schemaPath: string[],\n  ): Record<string, any> => {\n    const parser = this.createSchemaParser({ schema, typeName, schemaPath });\n    return parser.getInlineParseContent();\n  };\n\n  getParseContent = (\n    schema: string,\n    typeName: string | null,\n    schemaPath: string[],\n  ): Record<string, any> => {\n    const parser = this.createSchemaParser({ schema, typeName, schemaPath });\n    return parser.getParseContent();\n  };\n}\n","import * as nanoid from \"nanoid\";\n\nconst ALPHABET = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n\nexport const generateId = nanoid.customAlphabet(ALPHABET, 12);\n","import { consola } from \"consola\";\nimport type { CodeGenConfig } from \"../../configuration.js\";\nimport { NameResolver } from \"../../util/name-resolver.js\";\n\nexport class SpecificArgNameResolver extends NameResolver {\n  counter = 1;\n  constructor(config: CodeGenConfig, reservedNames: string[]) {\n    super(config, reservedNames, (variants) => {\n      const generatedVariant =\n        (variants[0] && `${variants[0]}${this.counter++}`) ||\n        `${this.config.specificArgNameResolverName}${this.counter++}`;\n      consola.debug(\n        \"generated fallback type name for specific arg - \",\n        generatedVariant,\n      );\n      return generatedVariant;\n    });\n  }\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport type {\n  GenerateApiConfiguration,\n  ParsedRoute,\n} from \"../../types/index.js\";\nimport type { CodeGenConfig } from \"../configuration.js\";\nimport {\n  DEFAULT_BODY_ARG_NAME,\n  RESERVED_BODY_ARG_NAMES,\n  RESERVED_HEADER_ARG_NAMES,\n  RESERVED_PATH_ARG_NAMES,\n  RESERVED_QUERY_ARG_NAMES,\n} from \"../constants.js\";\nimport type { SchemaComponentsMap } from \"../schema-components-map.js\";\nimport type { SchemaParserFabric } from \"../schema-parser/schema-parser-fabric.js\";\nimport type { SchemaUtils } from \"../schema-parser/schema-utils.js\";\nimport type { TemplatesWorker } from \"../templates-worker.js\";\nimport type { TypeNameFormatter } from \"../type-name-formatter.js\";\nimport { generateId } from \"../util/id.js\";\nimport { SpecificArgNameResolver } from \"./util/specific-arg-name-resolver.js\";\n\nconst CONTENT_KIND = {\n  JSON: \"JSON\",\n  JSON_API: \"JSON_API\",\n  URL_ENCODED: \"URL_ENCODED\",\n  FORM_DATA: \"FORM_DATA\",\n  IMAGE: \"IMAGE\",\n  OTHER: \"OTHER\",\n  TEXT: \"TEXT\",\n};\n\nexport class SchemaRoutes {\n  config: CodeGenConfig;\n  schemaParserFabric: SchemaParserFabric;\n  schemaUtils: SchemaUtils;\n  typeNameFormatter: TypeNameFormatter;\n  schemaComponentsMap: SchemaComponentsMap;\n  templatesWorker: TemplatesWorker;\n\n  FORM_DATA_TYPES: string[] = [];\n\n  routes: ParsedRoute[] = [];\n  hasSecurityRoutes = false;\n  hasQueryRoutes = false;\n  hasFormDataRoutes = false;\n\n  constructor(\n    config: CodeGenConfig,\n    schemaParserFabric: SchemaParserFabric,\n    schemaComponentsMap: SchemaComponentsMap,\n    templatesWorker: TemplatesWorker,\n    typeNameFormatter: TypeNameFormatter,\n  ) {\n    this.config = config;\n    this.schemaParserFabric = schemaParserFabric;\n    this.schemaUtils = this.schemaParserFabric.schemaUtils;\n    this.typeNameFormatter = typeNameFormatter;\n    this.schemaComponentsMap = schemaComponentsMap;\n    this.templatesWorker = templatesWorker;\n\n    this.FORM_DATA_TYPES = lodash.uniq([\n      this.schemaUtils.getSchemaType({ type: \"string\", format: \"file\" }),\n      this.schemaUtils.getSchemaType({ type: \"string\", format: \"binary\" }),\n    ]);\n  }\n\n  createRequestsMap = (routeInfoByMethodsMap) => {\n    const parameters = lodash.get(routeInfoByMethodsMap, \"parameters\");\n\n    return lodash.reduce(\n      routeInfoByMethodsMap,\n      (acc, requestInfo, method) => {\n        if (\n          method.startsWith(\"x-\") ||\n          [\"parameters\", \"$ref\"].includes(method)\n        ) {\n          return acc;\n        }\n\n        acc[method] = {\n          ...requestInfo,\n          parameters: lodash.compact(\n            lodash.concat(parameters, requestInfo.parameters),\n          ),\n        };\n\n        return acc;\n      },\n      {},\n    );\n  };\n\n  parseRouteName = (originalRouteName) => {\n    const routeName =\n      this.config.hooks.onPreBuildRoutePath(originalRouteName) ||\n      originalRouteName;\n\n    // TODO forbid leading symbols [\\]^` in a major release (allowed yet for backwards compatibility)\n    const pathParamMatches = (routeName || \"\").match(\n      /({[\\w[\\\\\\]^`][-_.\\w]*})|(:[\\w[\\\\\\]^`][-_.\\w]*:?)/g,\n    );\n\n    // used in case when path parameters is not declared in requestInfo.parameters (\"in\": \"path\")\n    const pathParams = lodash.reduce(\n      pathParamMatches,\n      (pathParams, match) => {\n        const paramName = match.replace(/\\{|\\}|:/g, \"\");\n\n        if (!paramName) return pathParams;\n\n        if (paramName.includes(\"-\")) {\n          consola.warn(\"wrong path param name\", paramName);\n        }\n\n        pathParams.push({\n          $match: match,\n          name: lodash.camelCase(paramName),\n          required: true,\n          type: \"string\",\n          description: \"\",\n          schema: {\n            type: \"string\",\n          },\n          in: \"path\",\n        });\n\n        return pathParams;\n      },\n      [],\n    );\n\n    let fixedRoute = pathParams.reduce((fixedRoute, pathParam, i, arr) => {\n      const insertion =\n        this.config.hooks.onInsertPathParam(\n          pathParam.name,\n          i,\n          arr,\n          fixedRoute,\n        ) || pathParam.name;\n      return fixedRoute.replace(pathParam.$match, `\\${${insertion}}`);\n    }, routeName || \"\");\n\n    const queryParamMatches = fixedRoute.match(/(\\{\\?.*\\})/g);\n    const queryParams = [];\n\n    if (queryParamMatches?.length) {\n      for (const match of queryParamMatches) {\n        fixedRoute = fixedRoute.replace(match, \"\");\n      }\n\n      const paramNames = lodash.uniq(\n        queryParamMatches\n          .join(\",\")\n          .replace(/(\\{\\?)|(\\})|\\s/g, \"\")\n          .split(\",\"),\n      );\n\n      for (const paramName of paramNames) {\n        // @ts-expect-error TS(2339) FIXME: Property 'includes' does not exist on type 'unknow... Remove this comment to see the full error message\n        if (paramName.includes(\"-\")) {\n          consola.warn(\"wrong query param name\", paramName);\n        }\n\n        queryParams.push({\n          $match: paramName,\n          // @ts-expect-error TS(2345) FIXME: Argument of type 'unknown' is not assignable to pa... Remove this comment to see the full error message\n          name: lodash.camelCase(paramName),\n          required: true,\n          type: \"string\",\n          description: \"\",\n          schema: {\n            type: \"string\",\n          },\n          in: \"query\",\n        });\n      }\n    }\n\n    const result = {\n      originalRoute: originalRouteName || \"\",\n      route: fixedRoute,\n      pathParams,\n      queryParams,\n    };\n\n    return this.config.hooks.onBuildRoutePath(result) || result;\n  };\n\n  getRouteParams = (\n    routeInfo,\n    pathParamsFromRouteName,\n    queryParamsFromRouteName,\n  ) => {\n    const { parameters } = routeInfo;\n\n    const routeParams = {\n      path: [],\n      header: [],\n      body: [],\n      query: [],\n      formData: [],\n      cookie: [],\n    };\n\n    lodash.each(parameters, (parameter) => {\n      const refTypeInfo =\n        this.schemaParserFabric.schemaUtils.getSchemaRefType(parameter);\n\n      let routeParam = null;\n\n      if (refTypeInfo?.rawTypeData.in && refTypeInfo.rawTypeData) {\n        if (!routeParams[refTypeInfo.rawTypeData.in]) {\n          routeParams[refTypeInfo.rawTypeData.in] = [];\n        }\n\n        routeParam = {\n          ...refTypeInfo.rawTypeData,\n          ...(refTypeInfo.rawTypeData.schema || {}),\n        };\n\n        if (parameter?.required && !routeParam.required) {\n          routeParam.required = parameter.required;\n        }\n      } else {\n        if (!parameter.in) return;\n\n        if (!routeParams[parameter.in]) {\n          routeParams[parameter.in] = [];\n        }\n\n        routeParam = {\n          ...parameter,\n          ...(parameter.schema || {}),\n        };\n      }\n\n      if (routeParam.in === \"path\") {\n        if (!routeParam.name) return;\n\n        routeParam.name = lodash.camelCase(routeParam.name);\n      }\n\n      if (routeParam) {\n        routeParams[routeParam.in].push(routeParam);\n      }\n    });\n\n    // used in case when path parameters is not declared in requestInfo.parameters (\"in\": \"path\")\n    for (const pathParam of pathParamsFromRouteName) {\n      const alreadyExist = routeParams.path.some(\n        (parameter) => parameter.name === pathParam.name,\n      );\n\n      if (!alreadyExist) {\n        routeParams.path.push(pathParam);\n      }\n    }\n\n    // used in case when path parameters is not declared in requestInfo.parameters (\"in\": \"path\")\n    for (const queryParam of queryParamsFromRouteName) {\n      const alreadyExist = routeParams.query.some(\n        (parameter) => parameter.name === queryParam.name,\n      );\n\n      if (!alreadyExist) {\n        routeParams.query.push(queryParam);\n      }\n    }\n\n    return routeParams;\n  };\n\n  getContentTypes = (requestInfo, extraContentTypes) =>\n    lodash.uniq(\n      lodash.compact([\n        ...(extraContentTypes || []),\n        ...lodash.flatten(\n          lodash.map(\n            requestInfo,\n            (requestInfoData) =>\n              requestInfoData && lodash.keys(requestInfoData.content),\n          ),\n        ),\n      ]),\n    );\n\n  getContentKind = (contentTypes) => {\n    if (contentTypes.includes(\"application/vnd.api+json\")) {\n      return CONTENT_KIND.JSON_API;\n    }\n\n    if (\n      contentTypes.some((contentType) =>\n        contentType.startsWith(\"application/json\"),\n      ) ||\n      contentTypes.some((contentType) => contentType.endsWith(\"+json\"))\n    ) {\n      return CONTENT_KIND.JSON;\n    }\n\n    if (contentTypes.includes(\"application/x-www-form-urlencoded\")) {\n      return CONTENT_KIND.URL_ENCODED;\n    }\n\n    if (contentTypes.includes(\"multipart/form-data\")) {\n      return CONTENT_KIND.FORM_DATA;\n    }\n\n    if (contentTypes.some((contentType) => contentType.includes(\"image/\"))) {\n      return CONTENT_KIND.IMAGE;\n    }\n\n    if (contentTypes.some((contentType) => contentType.startsWith(\"text/\"))) {\n      return CONTENT_KIND.TEXT;\n    }\n\n    return CONTENT_KIND.OTHER;\n  };\n\n  isSuccessStatus = (status) =>\n    (this.config.defaultResponseAsSuccess && status === \"default\") ||\n    (+status >= this.config.successResponseStatusRange[0] &&\n      +status <= this.config.successResponseStatusRange[1]) ||\n    status === \"2xx\";\n\n  getSchemaFromRequestType = (requestInfo) => {\n    const content = lodash.get(requestInfo, \"content\");\n\n    if (!content) return null;\n\n    /* content: { \"multipart/form-data\": { schema: {...} }, \"application/json\": { schema: {...} } } */\n\n    /* for example: dataType = \"multipart/form-data\" */\n    for (const dataType in content) {\n      if (content[dataType]?.schema) {\n        return {\n          ...content[dataType].schema,\n          dataType,\n        };\n      }\n    }\n\n    return null;\n  };\n\n  getTypeFromRequestInfo = ({\n    requestInfo,\n    parsedSchemas,\n    operationId,\n    defaultType,\n    typeName,\n  }) => {\n    // TODO: make more flexible pick schema without content type\n    const schema = this.getSchemaFromRequestType(requestInfo);\n    const refTypeInfo =\n      this.schemaParserFabric.schemaUtils.getSchemaRefType(requestInfo);\n\n    if (schema) {\n      const content = this.schemaParserFabric.getInlineParseContent(\n        schema,\n        typeName,\n        [operationId],\n      );\n      const foundedSchemaByName = parsedSchemas.find(\n        (parsedSchema) =>\n          this.typeNameFormatter.format(parsedSchema.name) === content,\n      );\n      const foundSchemaByContent = parsedSchemas.find((parsedSchema) =>\n        lodash.isEqual(parsedSchema.content, content),\n      );\n\n      const foundSchema = foundedSchemaByName || foundSchemaByContent;\n\n      return foundSchema\n        ? this.typeNameFormatter.format(foundSchema.name)\n        : content;\n    }\n\n    if (refTypeInfo) {\n      // const refTypeWithoutOpId = refType.replace(operationId, '');\n      // const foundedSchemaByName = _.find(parsedSchemas, ({ name }) => name === refType || name === refTypeWithoutOpId)\n\n      // TODO:HACK fix problem of swagger2openapi\n      const typeNameWithoutOpId = refTypeInfo.typeName.replace(operationId, \"\");\n      if (parsedSchemas.find((schema) => schema.name === typeNameWithoutOpId)) {\n        return this.typeNameFormatter.format(typeNameWithoutOpId);\n      }\n\n      switch (refTypeInfo.componentName) {\n        case \"schemas\":\n          return this.typeNameFormatter.format(refTypeInfo.typeName);\n        case \"responses\":\n        case \"requestBodies\":\n          return this.schemaParserFabric.getInlineParseContent(\n            this.getSchemaFromRequestType(refTypeInfo.rawTypeData),\n            refTypeInfo.typeName || null,\n            [operationId],\n          );\n        default:\n          return this.schemaParserFabric.getInlineParseContent(\n            refTypeInfo.rawTypeData,\n            refTypeInfo.typeName || null,\n            [operationId],\n          );\n      }\n    }\n\n    return defaultType || this.config.Ts.Keyword.Any;\n  };\n\n  getRequestInfoTypes = ({\n    requestInfos,\n    parsedSchemas,\n    operationId,\n    defaultType,\n  }) =>\n    lodash.reduce(\n      requestInfos,\n      (acc, requestInfo, status) => {\n        // @ts-expect-error TS(2554) FIXME: Expected 2 arguments, but got 1.\n        const contentTypes = this.getContentTypes([requestInfo]);\n\n        return [\n          ...acc,\n          {\n            ...(requestInfo || {}),\n            contentTypes: contentTypes,\n            contentKind: this.getContentKind(contentTypes),\n            type: this.schemaParserFabric.schemaUtils.safeAddNullToType(\n              requestInfo,\n              // @ts-expect-error TS(2345) FIXME: Argument of type '{ requestInfo: any; parsedSchema... Remove this comment to see the full error message\n              this.getTypeFromRequestInfo({\n                requestInfo,\n                parsedSchemas,\n                operationId,\n                defaultType,\n              }),\n            ),\n            description:\n              this.schemaParserFabric.schemaFormatters.formatDescription(\n                requestInfo.description || \"\",\n                true,\n              ),\n            status: Number.isNaN(+status) ? status : +status,\n            isSuccess: this.isSuccessStatus(status),\n          },\n        ];\n      },\n      [],\n    );\n\n  getResponseBodyInfo = (routeInfo, parsedSchemas) => {\n    const { produces, operationId, responses } = routeInfo;\n\n    const contentTypes = this.getContentTypes(responses, [\n      ...(produces || []),\n      routeInfo[\"x-accepts\"],\n    ]);\n\n    const responseInfos = this.getRequestInfoTypes({\n      requestInfos: responses,\n      parsedSchemas,\n      operationId,\n      defaultType: this.config.defaultResponseType,\n    });\n\n    const successResponse = responseInfos.find(\n      (response) => response.isSuccess,\n    );\n    const errorResponses = responseInfos.filter(\n      (response) =>\n        !response.isSuccess && response.type !== this.config.Ts.Keyword.Any,\n    );\n\n    const handleResponseHeaders = (src) => {\n      if (!src) {\n        return \"headers: {},\";\n      }\n      const headerTypes = Object.fromEntries(\n        Object.entries(src).map(([k, v]) => {\n          return [k, this.schemaUtils.getSchemaType(v)];\n        }),\n      );\n      const r = `headers: { ${Object.entries(headerTypes)\n        .map(([k, v]) => `\"${k}\": ${v}`)\n        .join(\",\")} },`;\n      return r;\n    };\n\n    return {\n      contentTypes,\n      responses: responseInfos,\n      success: {\n        schema: successResponse,\n        type: successResponse?.type || this.config.Ts.Keyword.Any,\n      },\n      error: {\n        schemas: errorResponses,\n        type:\n          this.config.Ts.UnionType(\n            errorResponses.map((response) => response.type),\n          ) || this.config.Ts.Keyword.Any,\n      },\n      full: {\n        types:\n          this.config.Ts.UnionType(\n            responseInfos.map(\n              (response) => `{\n      data: ${response.type}, status: ${response.status}, statusCode: ${\n        response.status\n      }, statusText: \"${response.description}\", ${handleResponseHeaders(\n        response.headers,\n      )} config: {} }`,\n            ),\n          ) || this.config.Ts.Keyword.Any,\n      },\n    };\n  };\n\n  convertRouteParamsIntoObject = (params) => {\n    return params.reduce(\n      (objectSchema, schemaPart) => {\n        if (!schemaPart || !schemaPart.name) return objectSchema;\n\n        return {\n          ...objectSchema,\n          properties: {\n            ...objectSchema.properties,\n            [schemaPart.name]: {\n              ...schemaPart,\n              ...(schemaPart.schema || {}),\n            },\n          },\n        };\n      },\n      {\n        properties: {},\n        type: \"object\",\n      },\n    );\n  };\n\n  getRequestBodyInfo = (routeInfo, routeParams, parsedSchemas, routeName) => {\n    const { requestBody, consumes, requestBodyName, operationId } = routeInfo;\n    let schema = null;\n    let content = null;\n\n    const contentTypes = this.getContentTypes(\n      [requestBody],\n      [...(consumes || []), routeInfo[\"x-contentType\"]],\n    );\n    let contentKind = this.getContentKind(contentTypes);\n\n    let typeName = null;\n\n    if (this.config.extractRequestBody) {\n      typeName = this.schemaUtils.resolveTypeName(routeName.usage, {\n        suffixes: this.config.extractingOptions.requestBodySuffix,\n        resolver: this.config.extractingOptions.requestBodyNameResolver,\n      });\n    }\n\n    if (routeParams.formData.length) {\n      contentKind = CONTENT_KIND.FORM_DATA;\n      schema = this.convertRouteParamsIntoObject(routeParams.formData);\n      content = this.schemaParserFabric.getInlineParseContent(\n        schema,\n        typeName,\n        [operationId],\n      );\n    } else if (contentKind === CONTENT_KIND.FORM_DATA) {\n      schema = this.getSchemaFromRequestType(requestBody);\n      content = this.schemaParserFabric.getInlineParseContent(\n        schema,\n        typeName,\n        [operationId],\n      );\n    } else if (requestBody) {\n      schema = this.getSchemaFromRequestType(requestBody);\n      content = this.schemaParserFabric.schemaUtils.safeAddNullToType(\n        requestBody,\n        // @ts-expect-error TS(2345) FIXME: Argument of type '{ requestInfo: any; parsedSchema... Remove this comment to see the full error message\n        this.getTypeFromRequestInfo({\n          requestInfo: requestBody,\n          parsedSchemas,\n          operationId,\n          typeName,\n        }),\n      );\n\n      // TODO: Refactor that.\n      // It needed for cases when swagger schema is not declared request body type as form data\n      // but request body data type contains form data types like File\n      if (\n        this.FORM_DATA_TYPES.some((dataType) =>\n          content.includes(`: ${dataType}`),\n        )\n      ) {\n        contentKind = CONTENT_KIND.FORM_DATA;\n      }\n    }\n\n    if (schema && !schema.$ref && this.config.extractRequestBody) {\n      schema = this.schemaParserFabric.createParsedComponent({\n        schema,\n        typeName,\n        schemaPath: [operationId],\n      });\n\n      if (schema?.typeData) {\n        schema.typeData.isExtractedRequestBody = true;\n      }\n      content = this.schemaParserFabric.getInlineParseContent({\n        $ref: schema.$ref,\n      });\n    }\n\n    if (\n      schema &&\n      schema.typeData &&\n      !schema.typeData.description &&\n      requestBody?.description\n    ) {\n      schema.typeData.description = requestBody.description;\n    }\n\n    return {\n      ...(requestBody || {}),\n      paramName: requestBodyName || requestBody?.name || DEFAULT_BODY_ARG_NAME,\n      contentTypes,\n      contentKind,\n      schema,\n      type: content,\n      required:\n        requestBody &&\n        (typeof requestBody.required === \"undefined\" || !!requestBody.required),\n    };\n  };\n\n  createRequestParamsSchema = ({\n    queryParams,\n    queryObjectSchema,\n    pathArgsSchemas,\n    extractRequestParams,\n    routeName,\n  }) => {\n    if (!queryParams || !queryParams.length) return null;\n\n    const pathParams = pathArgsSchemas.reduce((acc, pathArgSchema) => {\n      if (pathArgSchema.name) {\n        acc[pathArgSchema.name] = {\n          ...pathArgSchema,\n          in: \"path\",\n        };\n      }\n\n      return acc;\n    }, {});\n\n    const fixedQueryParams = lodash.reduce(\n      lodash.get(queryObjectSchema, \"properties\", {}),\n      (acc, property, name) => {\n        if (name && typeof property === \"object\") {\n          acc[name] = {\n            ...property,\n            in: \"query\",\n          };\n        }\n\n        return acc;\n      },\n      {},\n    );\n\n    const schema = {\n      ...queryObjectSchema,\n      properties: {\n        ...fixedQueryParams,\n        ...pathParams,\n      },\n    };\n\n    const fixedSchema = this.config.hooks.onCreateRequestParams(schema);\n\n    if (fixedSchema) return fixedSchema;\n\n    if (extractRequestParams) {\n      const generatedTypeName = this.schemaUtils.resolveTypeName(\n        routeName.usage,\n        {\n          suffixes: this.config.extractingOptions.requestParamsSuffix,\n          resolver: this.config.extractingOptions.requestParamsNameResolver,\n        },\n      );\n\n      const component = this.schemaParserFabric.createParsedComponent({\n        typeName: generatedTypeName,\n        schema: schema,\n      });\n\n      if (component.typeData) {\n        component.typeData.isExtractedRequestParams = true;\n      }\n\n      return component;\n    }\n\n    return schema;\n  };\n\n  extractResponseBodyIfItNeeded = (routeInfo, responseBodyInfo, routeName) => {\n    if (\n      responseBodyInfo.responses.length &&\n      responseBodyInfo.success &&\n      responseBodyInfo.success.schema\n    ) {\n      const typeName = this.schemaUtils.resolveTypeName(routeName.usage, {\n        suffixes: this.config.extractingOptions.responseBodySuffix,\n        resolver: this.config.extractingOptions.responseBodyNameResolver,\n      });\n\n      const idx = responseBodyInfo.responses.indexOf(\n        responseBodyInfo.success.schema,\n      );\n\n      const successResponse = responseBodyInfo.success;\n\n      if (successResponse.schema && !successResponse.schema.$ref) {\n        const contentKind = successResponse.schema.contentKind;\n        const schema = this.getSchemaFromRequestType(successResponse.schema);\n        successResponse.schema = this.schemaParserFabric.createParsedComponent({\n          schema,\n          typeName,\n          schemaPath: [routeInfo.operationId],\n        });\n        successResponse.schema.contentKind = contentKind;\n        if (successResponse.schema.typeData) {\n          successResponse.schema.typeData.isExtractedResponseBody = true;\n        }\n        successResponse.type = this.schemaParserFabric.getInlineParseContent({\n          $ref: successResponse.schema.$ref,\n        });\n\n        if (idx > -1) {\n          lodash.assign(responseBodyInfo.responses[idx], {\n            ...successResponse.schema,\n            type: successResponse.type,\n          });\n        }\n      }\n    }\n  };\n\n  extractResponseErrorIfItNeeded = (routeInfo, responseBodyInfo, routeName) => {\n    if (\n      responseBodyInfo.responses.length &&\n      responseBodyInfo.error.schemas &&\n      responseBodyInfo.error.schemas.length\n    ) {\n      const typeName = this.schemaUtils.resolveTypeName(routeName.usage, {\n        suffixes: this.config.extractingOptions.responseErrorSuffix,\n        resolver: this.config.extractingOptions.responseErrorNameResolver,\n      });\n\n      const errorSchemas = responseBodyInfo.error.schemas\n        .map(this.getSchemaFromRequestType)\n        .filter(Boolean);\n\n      if (!errorSchemas.length) return;\n\n      const schema = this.schemaParserFabric.parseSchema(\n        {\n          oneOf: errorSchemas,\n          title: errorSchemas\n            .map((schema) => schema.title)\n            .filter(Boolean)\n            .join(\" \"),\n          description: errorSchemas\n            .map((schema) => schema.description)\n            .filter(Boolean)\n            .join(\"\\n\"),\n        },\n        null,\n        [routeInfo.operationId],\n      );\n      const component = this.schemaComponentsMap.createComponent(\n        this.schemaComponentsMap.createRef([\"components\", \"schemas\", typeName]),\n        { ...schema },\n      );\n      responseBodyInfo.error.schemas = [component];\n      if (component.typeData) {\n        component.typeData.isExtractedResponseError = true;\n      }\n      responseBodyInfo.error.type = this.typeNameFormatter.format(\n        component.typeName,\n      );\n    }\n  };\n\n  getRouteName = (rawRouteInfo) => {\n    const { moduleName } = rawRouteInfo;\n    const { routeNameDuplicatesMap, templatesToRender } = this.config;\n    const routeNameTemplate = templatesToRender.routeName;\n\n    const routeNameFromTemplate = this.templatesWorker.renderTemplate(\n      routeNameTemplate,\n      {\n        routeInfo: rawRouteInfo,\n      },\n    );\n\n    const routeName =\n      this.config.hooks.onFormatRouteName(\n        rawRouteInfo,\n        routeNameFromTemplate,\n      ) || routeNameFromTemplate;\n\n    const duplicateIdentifier = `${moduleName}|${routeName}`;\n\n    if (routeNameDuplicatesMap.has(duplicateIdentifier)) {\n      routeNameDuplicatesMap.set(\n        duplicateIdentifier,\n        routeNameDuplicatesMap.get(duplicateIdentifier) + 1,\n      );\n\n      consola.warn(\n        `Module \"${moduleName}\" already has method \"${routeName}()\".`,\n        `This method has been renamed to \"${\n          routeName + routeNameDuplicatesMap.get(duplicateIdentifier)\n        }()\" to solve conflict names.`,\n      );\n    } else {\n      routeNameDuplicatesMap.set(duplicateIdentifier, 1);\n    }\n\n    const duplicates = routeNameDuplicatesMap.get(duplicateIdentifier);\n\n    const routeNameInfo = {\n      usage: routeName + (duplicates > 1 ? duplicates : \"\"),\n      original: routeName,\n      duplicate: duplicates > 1,\n    };\n\n    return (\n      this.config.hooks.onCreateRouteName(routeNameInfo, rawRouteInfo) ||\n      routeNameInfo\n    );\n  };\n\n  parseRouteInfo = (\n    rawRouteName,\n    routeInfo,\n    method,\n    usageSchema,\n    parsedSchemas,\n  ): ParsedRoute => {\n    const { security: globalSecurity } = usageSchema;\n    const { moduleNameIndex, moduleNameFirstTag, extractRequestParams } =\n      this.config;\n    const {\n      operationId,\n      requestBody,\n      security,\n      parameters,\n      summary,\n      description,\n      tags,\n      responses,\n      requestBodyName,\n      produces,\n      consumes,\n      ...otherInfo\n    } = routeInfo;\n    const {\n      route,\n      pathParams: pathParamsFromRouteName,\n      queryParams: queryParamsFromRouteName,\n    } = this.parseRouteName(rawRouteName);\n\n    const routeId = generateId();\n    const firstTag = tags && tags.length > 0 ? tags[0] : null;\n    const moduleName =\n      moduleNameFirstTag && firstTag\n        ? lodash.camelCase(firstTag)\n        : // @ts-expect-error TS(2345) FIXME: Argument of type 'unknown' is not assignable to pa... Remove this comment to see the full error message\n          lodash.camelCase(lodash.compact(route.split(\"/\"))[moduleNameIndex]);\n    let hasSecurity = !!globalSecurity?.length;\n    if (security) {\n      hasSecurity = security.length > 0;\n    }\n\n    const routeParams = this.getRouteParams(\n      routeInfo,\n      pathParamsFromRouteName,\n      queryParamsFromRouteName,\n    );\n\n    const pathArgs = routeParams.path.map((pathArgSchema) => ({\n      name: pathArgSchema.name,\n      optional: !pathArgSchema.required,\n      // mark it as any for now, because \"getInlineParseContent\" breaks type names of extracted enums\n      type: this.config.Ts.Keyword.Any,\n      description: pathArgSchema.description,\n    }));\n    const pathArgsNames = pathArgs.map((arg) => arg.name);\n\n    const responseBodyInfo = this.getResponseBodyInfo(routeInfo, parsedSchemas);\n\n    const rawRouteInfo = {\n      ...otherInfo,\n      pathArgs,\n      operationId,\n      method,\n      route: rawRouteName,\n      moduleName,\n      responsesTypes: responseBodyInfo.responses,\n      description,\n      tags,\n      summary,\n      responses,\n      produces,\n      requestBody,\n      consumes,\n      security,\n    };\n\n    const queryObjectSchema = this.convertRouteParamsIntoObject(\n      routeParams.query,\n    );\n    const pathObjectSchema = this.convertRouteParamsIntoObject(\n      routeParams.path,\n    );\n    const headersObjectSchema = this.convertRouteParamsIntoObject(\n      routeParams.header,\n    );\n\n    const routeName = this.getRouteName(rawRouteInfo);\n\n    const requestBodyInfo = this.getRequestBodyInfo(\n      routeInfo,\n      routeParams,\n      parsedSchemas,\n      routeName,\n    );\n\n    const requestParamsSchema = this.createRequestParamsSchema({\n      queryParams: routeParams.query,\n      pathArgsSchemas: routeParams.path,\n      queryObjectSchema,\n      extractRequestParams,\n      routeName,\n    });\n\n    if (this.config.extractResponseBody) {\n      this.extractResponseBodyIfItNeeded(\n        routeInfo,\n        responseBodyInfo,\n        routeName,\n      );\n    }\n    if (this.config.extractResponseError) {\n      this.extractResponseErrorIfItNeeded(\n        routeInfo,\n        responseBodyInfo,\n        routeName,\n      );\n    }\n\n    const typeName = this.schemaUtils.resolveTypeName(routeName.usage, {\n      suffixes: this.config.extractingOptions.requestParamsSuffix,\n      resolver: this.config.extractingOptions.requestParamsNameResolver,\n      shouldReserve: false,\n    });\n\n    const queryType = routeParams.query.length\n      ? this.schemaParserFabric.getInlineParseContent(queryObjectSchema, null, [\n          typeName,\n        ])\n      : null;\n    const pathType = routeParams.path.length\n      ? this.schemaParserFabric.getInlineParseContent(pathObjectSchema, null, [\n          typeName,\n        ])\n      : null;\n    const headersType = routeParams.header.length\n      ? this.schemaParserFabric.getInlineParseContent(\n          headersObjectSchema,\n          null,\n          [typeName],\n        )\n      : null;\n\n    const nameResolver = new SpecificArgNameResolver(\n      this.config,\n      pathArgsNames,\n    );\n\n    const specificArgs = {\n      query: queryType\n        ? {\n            name: nameResolver.resolve(RESERVED_QUERY_ARG_NAMES),\n            optional: this.schemaParserFabric.parseSchema(\n              queryObjectSchema,\n              null,\n              [routeName.usage],\n            ).allFieldsAreOptional,\n            type: queryType,\n          }\n        : void 0,\n      body: requestBodyInfo.type\n        ? {\n            ...requestBodyInfo,\n            name: nameResolver.resolve([\n              requestBodyInfo.paramName,\n              ...RESERVED_BODY_ARG_NAMES,\n            ]),\n            optional: !requestBodyInfo.required,\n            type: requestBodyInfo.type,\n          }\n        : void 0,\n      pathParams: pathType\n        ? {\n            name: nameResolver.resolve(RESERVED_PATH_ARG_NAMES),\n            optional: this.schemaParserFabric.parseSchema(\n              pathObjectSchema,\n              null,\n              [routeName.usage],\n            ).allFieldsAreOptional,\n            type: pathType,\n          }\n        : void 0,\n      headers: headersType\n        ? {\n            name: nameResolver.resolve(RESERVED_HEADER_ARG_NAMES),\n            optional: this.schemaParserFabric.parseSchema(\n              headersObjectSchema,\n              null,\n              [routeName.usage],\n            ).allFieldsAreOptional,\n            type: headersType,\n          }\n        : void 0,\n    };\n\n    pathArgs.forEach((pathArg, i) => {\n      pathArg.type = this.schemaParserFabric.getInlineParseContent(\n        routeParams.path[i].schema,\n        null,\n        [typeName],\n      );\n    });\n\n    return {\n      id: routeId,\n      namespace: moduleName.replace(/^(\\d)/, \"v$1\"),\n      routeName,\n      routeParams,\n      requestBodyInfo,\n      responseBodyInfo,\n      specificArgs,\n      queryObjectSchema,\n      pathObjectSchema,\n      headersObjectSchema,\n      responseBodySchema: responseBodyInfo.success.schema,\n      requestBodySchema: requestBodyInfo.schema,\n      specificArgNameResolver: nameResolver,\n      request: {\n        contentTypes: requestBodyInfo.contentTypes,\n        parameters: pathArgs,\n        path: route,\n        formData: requestBodyInfo.contentKind === CONTENT_KIND.FORM_DATA,\n        isQueryBody: requestBodyInfo.contentKind === CONTENT_KIND.URL_ENCODED,\n        security: hasSecurity,\n        method: method,\n        requestParams: requestParamsSchema,\n\n        payload: specificArgs.body,\n        query: specificArgs.query,\n        pathParams: specificArgs.pathParams,\n        headers: specificArgs.headers,\n      },\n      response: {\n        contentTypes: responseBodyInfo.contentTypes,\n        type: responseBodyInfo.success.type,\n        errorType: responseBodyInfo.error.type,\n        fullTypes: responseBodyInfo.full.types,\n      },\n      raw: rawRouteInfo,\n    };\n  };\n\n  attachSchema = ({ usageSchema, parsedSchemas }) => {\n    this.config.routeNameDuplicatesMap.clear();\n\n    const pathsEntries = lodash.entries(usageSchema.paths);\n\n    for (const [rawRouteName, routeInfoByMethodsMap] of pathsEntries) {\n      const routeInfosMap = this.createRequestsMap(routeInfoByMethodsMap);\n\n      for (const [method, routeInfo] of Object.entries(routeInfosMap)) {\n        const parsedRouteInfo = this.parseRouteInfo(\n          rawRouteName,\n          routeInfo,\n          method,\n          usageSchema,\n          parsedSchemas,\n        );\n        const processedRouteInfo =\n          this.config.hooks.onCreateRoute(parsedRouteInfo);\n        if (processedRouteInfo !== false) {\n          const route = processedRouteInfo || parsedRouteInfo;\n\n          if (!this.hasSecurityRoutes && route.security) {\n            this.hasSecurityRoutes = route.security;\n          }\n          if (!this.hasQueryRoutes && route.hasQuery) {\n            this.hasQueryRoutes = route.hasQuery;\n          }\n          if (!this.hasFormDataRoutes && route.hasFormDataParams) {\n            this.hasFormDataRoutes = route.hasFormDataParams;\n          }\n\n          this.routes.push(route);\n        }\n      }\n    }\n  };\n\n  getGroupedRoutes = () => {\n    const groupedRoutes = this.routes.reduce(\n      (modules, route) => {\n        if (route.namespace) {\n          if (!modules[route.namespace]) {\n            modules[route.namespace] = [];\n          }\n\n          modules[route.namespace].push(route);\n        } else {\n          modules.$outOfModule.push(route);\n        }\n\n        return modules;\n      },\n      { $outOfModule: [] as ParsedRoute[] },\n    );\n\n    const routeGroups = lodash.reduce(\n      groupedRoutes,\n      (acc, routesGroup, moduleName) => {\n        if (moduleName === \"$outOfModule\") {\n          acc.outOfModule = routesGroup;\n        } else {\n          if (!acc.combined) {\n            acc.combined = [];\n          }\n          acc.combined.push({\n            moduleName,\n            routes: routesGroup.map((route) => {\n              const { original: originalName, usage: usageName } =\n                route.routeName;\n\n              // TODO: https://github.com/acacode/swagger-typescript-api/issues/152\n              // TODO: refactor\n              if (\n                routesGroup.length > 1 &&\n                usageName !== originalName &&\n                !routesGroup.some(\n                  ({ routeName, id }) =>\n                    id !== route.id && originalName === routeName.original,\n                )\n              ) {\n                return {\n                  ...route,\n                  routeName: {\n                    ...route.routeName,\n                    usage: originalName,\n                  },\n                };\n              }\n\n              return route;\n            }),\n          });\n        }\n        return acc;\n      },\n      {} as GenerateApiConfiguration[\"routes\"],\n    );\n\n    if (this.config.sortRoutes) {\n      if (routeGroups.outOfModule) {\n        routeGroups.outOfModule = this.sortRoutes(routeGroups.outOfModule);\n      }\n      if (routeGroups.combined) {\n        lodash.each(routeGroups.combined, (routeGroup) => {\n          routeGroup.routes = this.sortRoutes(routeGroup.routes);\n        });\n      }\n    }\n\n    return routeGroups;\n  };\n\n  sortRoutes = (routes: ParsedRoute[]) => {\n    return lodash\n      .slice(routes)\n      .sort((routeA, routeB) =>\n        routeA.routeName.usage.localeCompare(routeB.routeName.usage),\n      );\n  };\n}\n","import lodash from \"lodash\";\nimport type { OpenAPI } from \"openapi-types\";\nimport type { CodeGenConfig } from \"./configuration.js\";\nimport type { SwaggerSchemaResolver } from \"./swagger-schema-resolver.js\";\n\n// TODO: WIP\n// this class will be needed to walk by schema everywhere\nexport class SchemaWalker {\n  config: CodeGenConfig;\n  swaggerSchemaResolver: SwaggerSchemaResolver;\n  schemas = new Map<string, OpenAPI.Document>();\n  caches = new Map<string, OpenAPI.Document>();\n\n  constructor(\n    config: CodeGenConfig,\n    swaggerSchemaResolver: SwaggerSchemaResolver,\n  ) {\n    this.config = config;\n    this.swaggerSchemaResolver = swaggerSchemaResolver;\n  }\n\n  addSchema = (name: string, schema: OpenAPI.Document) => {\n    this.schemas.set(name, structuredClone(schema));\n  };\n\n  _isLocalRef = (ref: string) => {\n    return ref.startsWith(\"#\");\n  };\n\n  _isRemoteRef = (ref: string) => {\n    return ref.startsWith(\"http://\") || ref.startsWith(\"https://\");\n  };\n\n  _getRefDataFromSchema = (schema: Record<string, unknown>, ref: string) => {\n    const path = ref.replace(\"#\", \"\").split(\"/\");\n    const refData = lodash.get(schema, path);\n    if (refData) {\n      this.caches.set(ref, refData);\n    }\n    return refData;\n  };\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport type { CodeGenConfig } from \"../configuration.js\";\n\nexport class Request {\n  config: CodeGenConfig;\n\n  constructor(config: CodeGenConfig) {\n    this.config = config;\n  }\n\n  async download({\n    url,\n    authToken,\n    ...options\n  }: {\n    url: string;\n    authToken?: string;\n    options?: Partial<RequestInit>;\n  }) {\n    const requestOptions: Partial<RequestInit> = {};\n\n    if (authToken) {\n      requestOptions.headers = {\n        Authorization: authToken,\n      };\n    }\n\n    lodash.merge(requestOptions, options, this.config.requestOptions);\n\n    try {\n      const response = await fetch(url, requestOptions);\n      return await response.text();\n    } catch (error) {\n      const message = `error while fetching data from URL \"${url}\"`;\n      consola.error(message, error);\n      return message;\n    }\n  }\n}\n","import { consola } from \"consola\";\nimport * as yaml from \"js-yaml\";\nimport lodash from \"lodash\";\nimport type { OpenAPI, OpenAPIV2 } from \"openapi-types\";\nimport * as swagger2openapi from \"swagger2openapi\";\nimport type { CodeGenConfig } from \"./configuration.js\";\nimport type { FileSystem } from \"./util/file-system.js\";\nimport { Request } from \"./util/request.js\";\n\nexport class SwaggerSchemaResolver {\n  config: CodeGenConfig;\n  fileSystem: FileSystem;\n  request: Request;\n\n  constructor(config: CodeGenConfig, fileSystem: FileSystem) {\n    this.config = config;\n    this.fileSystem = fileSystem;\n    this.request = new Request(config);\n  }\n\n  async create() {\n    const { spec, patch, input, url, authorizationToken } = this.config;\n\n    if (spec) {\n      return await this.convertSwaggerObject(spec, { patch });\n    }\n\n    const swaggerSchemaFile = await this.fetchSwaggerSchemaFile(\n      input,\n      url,\n      authorizationToken,\n    );\n    const swaggerSchemaObject =\n      this.processSwaggerSchemaFile(swaggerSchemaFile);\n    return await this.convertSwaggerObject(swaggerSchemaObject, { patch });\n  }\n\n  convertSwaggerObject(\n    swaggerSchema: OpenAPI.Document,\n    converterOptions: { patch?: boolean },\n  ): Promise<{\n    usageSchema: OpenAPI.Document;\n    originalSchema: OpenAPI.Document;\n  }> {\n    return new Promise((resolve) => {\n      const result = structuredClone(swaggerSchema);\n      result.info = lodash.merge(\n        {\n          title: \"No title\",\n          version: \"\",\n        },\n        result.info,\n      );\n\n      if (!Object.hasOwn(result, \"openapi\")) {\n        result.paths = lodash.merge({}, result.paths);\n\n        swagger2openapi.convertObj(\n          result as OpenAPIV2.Document,\n          {\n            ...converterOptions,\n            resolveInternal: true,\n            warnOnly: true,\n            refSiblings: \"preserve\",\n            rbname: \"requestBodyName\",\n          },\n          (err, options) => {\n            const parsedSwaggerSchema = lodash.get(\n              err,\n              \"options.openapi\",\n              lodash.get(options, \"openapi\"),\n            );\n            if (!parsedSwaggerSchema && err) {\n              throw err;\n            }\n            this.config.update({ convertedFromSwagger2: true });\n            resolve({\n              usageSchema: parsedSwaggerSchema,\n              originalSchema: result,\n            });\n          },\n        );\n      } else {\n        resolve({\n          usageSchema: result,\n          originalSchema: structuredClone(result),\n        });\n      }\n    });\n  }\n\n  getSwaggerSchemaByPath = (pathToSwagger: string) => {\n    consola.info(`try to get swagger by path \"${pathToSwagger}\"`);\n    return this.fileSystem.getFileContent(pathToSwagger);\n  };\n\n  async fetchSwaggerSchemaFile(\n    pathToSwagger: string,\n    urlToSwagger: string,\n    authToken?: string,\n  ) {\n    if (this.fileSystem.pathIsExist(pathToSwagger)) {\n      return this.getSwaggerSchemaByPath(pathToSwagger);\n    }\n    consola.info(`try to get swagger by URL \"${urlToSwagger}\"`);\n    return await this.request.download({\n      url: urlToSwagger,\n      authToken: authToken,\n    });\n  }\n\n  processSwaggerSchemaFile(file: string) {\n    if (typeof file !== \"string\") return file;\n\n    try {\n      return JSON.parse(file);\n    } catch (e) {\n      return yaml.load(file);\n    }\n  }\n\n  fixSwaggerSchema({ usageSchema, originalSchema }) {\n    const usagePaths = lodash.get(usageSchema, \"paths\");\n    const originalPaths = lodash.get(originalSchema, \"paths\");\n\n    // walk by routes\n    lodash.each(usagePaths, (usagePathObject, route) => {\n      const originalPathObject = lodash.get(originalPaths, route);\n\n      // walk by methods\n      lodash.each(usagePathObject, (usageRouteInfo, methodName) => {\n        const originalRouteInfo = lodash.get(originalPathObject, methodName);\n        const usageRouteParams = lodash.get(usageRouteInfo, \"parameters\", []);\n        const originalRouteParams = lodash.get(\n          originalRouteInfo,\n          \"parameters\",\n          [],\n        );\n\n        if (typeof usageRouteInfo === \"object\") {\n          usageRouteInfo.consumes = lodash.uniq(\n            lodash.compact([\n              ...(usageRouteInfo.consumes || []),\n              ...(originalRouteInfo.consumes || []),\n            ]),\n          );\n          usageRouteInfo.produces = lodash.uniq(\n            lodash.compact([\n              ...(usageRouteInfo.produces || []),\n              ...(originalRouteInfo.produces || []),\n            ]),\n          );\n        }\n\n        lodash.each(originalRouteParams, (originalRouteParam) => {\n          const existUsageParam = usageRouteParams.find(\n            (param) =>\n              originalRouteParam.in === param.in &&\n              originalRouteParam.name === param.name,\n          );\n          if (!existUsageParam) {\n            usageRouteParams.push(originalRouteParam);\n          }\n        });\n      });\n    });\n  }\n}\n","import * as path from \"node:path\";\nimport * as url from \"node:url\";\nimport { consola } from \"consola\";\nimport * as Eta from \"eta\";\nimport lodash from \"lodash\";\nimport type { CodeGenProcess } from \"./code-gen-process.js\";\nimport type { CodeGenConfig } from \"./configuration.js\";\nimport type { FileSystem } from \"./util/file-system.js\";\n\nexport class TemplatesWorker {\n  config: CodeGenConfig;\n  fileSystem: FileSystem;\n  getRenderTemplateData: CodeGenProcess[\"getRenderTemplateData\"];\n\n  constructor(\n    config: CodeGenConfig,\n    fileSystem: FileSystem,\n    getRenderTemplateData: CodeGenProcess[\"getRenderTemplateData\"],\n  ) {\n    this.config = config;\n    this.fileSystem = fileSystem;\n    this.getRenderTemplateData = getRenderTemplateData;\n    if (this.config.debug) consola.level = Number.MAX_SAFE_INTEGER;\n    if (this.config.silent) consola.level = 0;\n  }\n\n  getTemplatePaths = (\n    config: CodeGenConfig,\n  ): CodeGenConfig[\"templatePaths\"] => {\n    const __dirname = path.dirname(url.fileURLToPath(import.meta.url));\n    const baseTemplatesPath = path.resolve(__dirname, \"../templates/base\");\n    const defaultTemplatesPath = path.resolve(\n      __dirname,\n      \"../templates/default\",\n    );\n    const modularTemplatesPath = path.resolve(\n      __dirname,\n      \"../templates/modular\",\n    );\n    const originalTemplatesPath = config.modular\n      ? modularTemplatesPath\n      : defaultTemplatesPath;\n    const customTemplatesPath =\n      config.templates && path.resolve(process.cwd(), config.templates);\n\n    return {\n      /** `templates/base` */\n      base: baseTemplatesPath,\n      /** `templates/default` */\n      default: defaultTemplatesPath,\n      /** `templates/modular` */\n      modular: modularTemplatesPath,\n      /** usage path if `--templates` option is not set */\n      original: originalTemplatesPath,\n      /** custom path to templates (`--templates`) */\n      custom: customTemplatesPath,\n    };\n  };\n\n  cropExtension = (path: string) =>\n    this.config.templateExtensions.reduce(\n      (path, ext) => (path.endsWith(ext) ? path.replace(ext, \"\") : path),\n      path,\n    );\n\n  getTemplateFullPath = (path_: string, fileName: string) => {\n    const raw = path.resolve(path_, \"./\", this.cropExtension(fileName));\n    const pathVariants = this.config.templateExtensions.map(\n      (extension) => `${raw}${extension}`,\n    );\n\n    return pathVariants.find(\n      (variant) => !!this.fileSystem.pathIsExist(variant),\n    );\n  };\n\n  requireFnFromTemplate = async (packageOrPath: string) => {\n    const isPath =\n      packageOrPath.startsWith(\"./\") || packageOrPath.startsWith(\"../\");\n\n    if (isPath) {\n      return await import(\n        path.resolve(\n          this.config.templatePaths.custom ||\n            this.config.templatePaths.original,\n          packageOrPath,\n        )\n      );\n    }\n\n    return await import(packageOrPath);\n  };\n\n  getTemplate = (name: string, fileName: string, path?: string) => {\n    const { templatePaths } = this.config;\n\n    if (path) {\n      return this.fileSystem.getFileContent(path);\n    }\n\n    if (!fileName) return \"\";\n\n    const customFullPath =\n      templatePaths.custom &&\n      this.getTemplateFullPath(templatePaths.custom, fileName);\n    let fileContent =\n      customFullPath && this.fileSystem.getFileContent(customFullPath);\n\n    if (fileContent) {\n      consola.info(\n        `\"${name.toLowerCase()}\" template found in \"${templatePaths.custom}\"`,\n      );\n      return fileContent;\n    }\n\n    const baseFullPath = this.getTemplateFullPath(templatePaths.base, fileName);\n\n    if (baseFullPath) {\n      fileContent = this.fileSystem.getFileContent(baseFullPath);\n    } else {\n      if (templatePaths.custom) {\n        consola.warn(\n          \"Code generator will use the default template:\",\n          `\"${name.toLowerCase()}\"`,\n          \"template not found in\",\n          `\"${templatePaths.custom}\"`,\n        );\n      } else {\n        consola.info(\n          `Code generator will use the default template for \"${name.toLowerCase()}\"`,\n        );\n      }\n    }\n\n    const originalFullPath = this.getTemplateFullPath(\n      templatePaths.original,\n      fileName,\n    );\n\n    if (originalFullPath) {\n      fileContent = this.fileSystem.getFileContent(originalFullPath);\n    }\n\n    return fileContent;\n  };\n\n  getTemplates = ({ templatePaths }: CodeGenConfig) => {\n    if (templatePaths.custom) {\n      consola.info(\n        `try to read templates from directory \"${templatePaths.custom}\"`,\n      );\n    }\n\n    return lodash.reduce(\n      this.config.templateInfos,\n      (acc, { name, fileName }) => ({\n        ...acc,\n        [name]: this.getTemplate(name, fileName),\n      }),\n      {},\n    );\n  };\n\n  findTemplateWithExt = (path: string) => {\n    const raw = this.cropExtension(path);\n    const pathVariants = this.config.templateExtensions.map(\n      (extension) => `${raw}${extension}`,\n    );\n    return pathVariants.find((variant) => this.fileSystem.pathIsExist(variant));\n  };\n\n  getTemplateContent = (path_: string) => {\n    const foundTemplatePathKey = lodash\n      .keys(this.config.templatePaths)\n      .find((key) => path_.startsWith(`@${key}`));\n\n    if (foundTemplatePathKey) {\n      const rawPath = path.resolve(\n        path_.replace(\n          `@${foundTemplatePathKey}`,\n          lodash.get(this.config.templatePaths, foundTemplatePathKey),\n        ),\n      );\n      const fixedPath = this.findTemplateWithExt(rawPath);\n\n      if (fixedPath) {\n        return this.fileSystem.getFileContent(fixedPath);\n      }\n    }\n\n    const customPath =\n      this.config.templatePaths.custom &&\n      this.findTemplateWithExt(\n        path.resolve(this.config.templatePaths.custom, path_),\n      );\n\n    if (customPath) {\n      return this.fileSystem.getFileContent(customPath);\n    }\n\n    const originalPath = this.findTemplateWithExt(\n      path.resolve(this.config.templatePaths.original, path_),\n    );\n\n    if (originalPath) {\n      return this.fileSystem.getFileContent(originalPath);\n    }\n\n    return \"\";\n  };\n\n  renderTemplate = (\n    template: string,\n    configuration: object,\n    options: object = {},\n  ) => {\n    if (!template) return \"\";\n\n    return Eta.render(\n      template,\n      {\n        ...this.getRenderTemplateData(),\n        ...configuration,\n      },\n      {\n        async: false,\n        ...options,\n        includeFile: (\n          path: string,\n          configuration: object,\n          options: object = {},\n        ) => {\n          return this.renderTemplate(\n            this.getTemplateContent(path),\n            configuration,\n            options,\n          );\n        },\n      },\n    );\n  };\n}\n","import type { CodeFormatter } from \"../code-formatter.js\";\nimport type { CodeGenConfig } from \"../configuration.js\";\n\nexport interface TranslatorIO {\n  fileName: string;\n  fileExtension: string;\n  fileContent: string;\n}\n\nexport class Translator {\n  config: CodeGenConfig;\n  codeFormatter: CodeFormatter;\n\n  constructor(config: CodeGenConfig, codeFormatter: CodeFormatter) {\n    this.config = config;\n    this.codeFormatter = codeFormatter;\n  }\n\n  translate(_input: TranslatorIO): Promise<TranslatorIO[]> {\n    throw new Error(\"not implemented\");\n  }\n}\n","import * as typescript from \"typescript\";\nimport { Translator, type TranslatorIO } from \"./translator.js\";\n\nexport class JavascriptTranslator extends Translator {\n  compileTSCode = (input: TranslatorIO): Record<string, string> => {\n    const fileNameFull = `${input.fileName}${input.fileExtension}`;\n    const output = {};\n    const host = typescript.createCompilerHost(\n      this.config.compilerTsConfig,\n      true,\n    );\n    const fileNames = [fileNameFull];\n    const originalSourceFileGet = host.getSourceFile.bind(host);\n    host.getSourceFile = (\n      sourceFileName,\n      languageVersion,\n      onError,\n      shouldCreateNewSourceFile,\n    ) => {\n      if (sourceFileName !== fileNameFull)\n        return originalSourceFileGet(\n          sourceFileName,\n          languageVersion,\n          onError,\n          shouldCreateNewSourceFile,\n        );\n\n      return typescript.createSourceFile(\n        sourceFileName,\n        input.fileContent,\n        languageVersion,\n        true,\n        typescript.ScriptKind.TS,\n      );\n    };\n\n    host.writeFile = (fileName, contents) => {\n      output[fileName] = contents;\n    };\n\n    typescript\n      .createProgram(fileNames, this.config.compilerTsConfig, host)\n      .emit();\n\n    return output;\n  };\n\n  translate = async (input) => {\n    const compiled = this.compileTSCode(input);\n\n    const jsFileName = `${input.fileName}${typescript.Extension.Js}`;\n    const dtsFileName = `${input.fileName}${typescript.Extension.Dts}`;\n    const sourceContent = compiled[jsFileName];\n    const tsImportRows = input.fileContent\n      .split(\"\\n\")\n      .filter((line) => line.startsWith(\"import \"));\n    const declarationContent = compiled[dtsFileName]\n      .split(\"\\n\")\n      .map((line) => {\n        if (line.startsWith(\"import \")) {\n          return tsImportRows.shift();\n        }\n        return line;\n      })\n      .join(\"\\n\");\n\n    return [\n      {\n        fileName: input.fileName,\n        fileExtension: typescript.Extension.Js,\n        fileContent: await this.codeFormatter.formatCode(sourceContent),\n      },\n      {\n        fileName: input.fileName,\n        fileExtension: typescript.Extension.Dts,\n        fileContent: await this.codeFormatter.formatCode(declarationContent),\n      },\n    ];\n  };\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport type { CodeGenConfig } from \"./configuration.js\";\n\ntype FormattingSchemaType = \"enum-key\" | \"type-name\";\n\nexport class TypeNameFormatter {\n  formattedModelNamesMap = new Map<string, string>();\n  config: CodeGenConfig;\n\n  constructor(config: CodeGenConfig) {\n    this.config = config;\n  }\n\n  format = (name: string, options: { type?: FormattingSchemaType } = {}) => {\n    const schemaType = options.type ?? \"type-name\";\n\n    const typePrefix =\n      schemaType === \"enum-key\"\n        ? this.config.enumKeyPrefix\n        : this.config.typePrefix;\n    const typeSuffix =\n      schemaType === \"enum-key\"\n        ? this.config.enumKeySuffix\n        : this.config.typeSuffix;\n\n    const hashKey = `${typePrefix}_${name}_${typeSuffix}`;\n\n    if (typeof name !== \"string\") {\n      consola.warn(\"wrong model name\", name);\n      return name;\n    }\n\n    // constant names like LEFT_ARROW, RIGHT_FORWARD, ETC_KEY, _KEY_NUM_\n    if (/^(?!\\d)([A-Z0-9_]{1,})$/g.test(name)) {\n      return lodash.compact([typePrefix, name, typeSuffix]).join(\"_\");\n    }\n\n    if (this.formattedModelNamesMap.has(hashKey)) {\n      return this.formattedModelNamesMap.get(hashKey);\n    }\n\n    const fixedModelName = this.fixModelName(name, { type: schemaType });\n\n    const formattedName = lodash\n      .startCase(`${typePrefix}_${fixedModelName}_${typeSuffix}`)\n      .replace(/\\s/g, \"\");\n    const formattedResultName =\n      this.config.hooks.onFormatTypeName(formattedName, name, schemaType) ||\n      formattedName;\n\n    this.formattedModelNamesMap.set(hashKey, formattedResultName);\n\n    return formattedResultName;\n  };\n\n  isValidName = (name: string) => /^([A-Za-z$_]{1,})$/g.test(name);\n\n  fixModelName = (\n    name: string,\n    options: { type?: FormattingSchemaType },\n  ): string => {\n    if (!this.isValidName(name)) {\n      if (!/^[a-zA-Z_$]/g.test(name)) {\n        const fixPrefix =\n          options.type === \"enum-key\"\n            ? this.config.fixInvalidEnumKeyPrefix\n            : this.config.fixInvalidTypeNamePrefix;\n        return `${fixPrefix} ${name}`;\n      }\n\n      // specific replaces for TSOA 3.x\n      if (name.includes(\".\")) {\n        return name\n          .replace(/Exclude_keyof[A-Za-z]+/g, () => \"ExcludeKeys\")\n          .replace(/%22~AND~%22/g, \"And\")\n          .replace(/%22~OR~%22/g, \"Or\")\n          .replace(/(\\.?%22)|\\./g, \"_\")\n          .replace(/__+$/, \"\");\n      }\n\n      if (name.includes(\"-\")) {\n        return lodash.startCase(name).replace(/ /g, \"\");\n      }\n    }\n\n    return name;\n  };\n}\n","import * as fs from \"node:fs\";\nimport * as path from \"node:path\";\nimport * as url from \"node:url\";\nimport { consola } from \"consola\";\nimport { FILE_PREFIX } from \"../constants.js\";\n\nexport class FileSystem {\n  getFileContent = (path: string) => {\n    return fs.readFileSync(path, { encoding: \"utf8\" });\n  };\n\n  readDir = (path: string) => {\n    return fs.readdirSync(path);\n  };\n\n  pathIsDir = (path: string) => {\n    if (!path) return false;\n\n    try {\n      const stat = fs.statSync(path);\n      return stat.isDirectory();\n    } catch (e) {\n      return false;\n    }\n  };\n\n  cropExtension = (fileName: string) => {\n    const fileNameParts = fileName.split(\".\");\n\n    if (fileNameParts.length > 1) {\n      fileNameParts.pop();\n    }\n\n    return fileNameParts.join(\".\");\n  };\n\n  removeDir = (path: string) => {\n    try {\n      if (typeof fs.rmSync === \"function\") {\n        fs.rmSync(path, { recursive: true });\n      } else {\n        fs.rmdirSync(path, { recursive: true });\n      }\n    } catch (e) {\n      consola.debug(\"failed to remove dir\", e);\n    }\n  };\n\n  createDir = (path: string) => {\n    try {\n      fs.mkdirSync(path, { recursive: true });\n    } catch (e) {\n      consola.debug(\"failed to create dir\", e);\n    }\n  };\n\n  cleanDir = (path: string) => {\n    this.removeDir(path);\n    this.createDir(path);\n  };\n\n  pathIsExist = (path: string) => {\n    return !!path && fs.existsSync(path);\n  };\n\n  createFile = ({ path: path_, fileName, content, withPrefix }) => {\n    const __dirname = path.dirname(url.fileURLToPath(import.meta.url));\n    const absolutePath = path.resolve(__dirname, path_, `./${fileName}`);\n    const fileContent = `${withPrefix ? FILE_PREFIX : \"\"}${content}`;\n\n    return fs.writeFileSync(absolutePath, fileContent);\n  };\n}\n","import { consola } from \"consola\";\nimport lodash from \"lodash\";\nimport * as typescript from \"typescript\";\nimport type {\n  GenerateApiConfiguration,\n  SchemaComponent,\n} from \"../types/index.js\";\nimport { CodeFormatter } from \"./code-formatter.js\";\nimport { CodeGenConfig } from \"./configuration.js\";\nimport { SchemaComponentsMap } from \"./schema-components-map.js\";\nimport { SchemaParserFabric } from \"./schema-parser/schema-parser-fabric.js\";\nimport { SchemaRoutes } from \"./schema-routes/schema-routes.js\";\nimport { SchemaWalker } from \"./schema-walker.js\";\nimport { SwaggerSchemaResolver } from \"./swagger-schema-resolver.js\";\nimport { TemplatesWorker } from \"./templates-worker.js\";\nimport { JavascriptTranslator } from \"./translators/javascript.js\";\nimport type { TranslatorIO } from \"./translators/translator.js\";\nimport { TypeNameFormatter } from \"./type-name-formatter.js\";\nimport { FileSystem } from \"./util/file-system.js\";\nimport { internalCase } from \"./util/internal-case.js\";\nimport { NameResolver } from \"./util/name-resolver.js\";\nimport { pascalCase } from \"./util/pascal-case.js\";\nimport { sortByProperty } from \"./util/sort-by-property.js\";\n\nconst PATCHABLE_INSTANCES = [\n  \"schemaWalker\",\n  \"swaggerSchemaResolver\",\n  \"schemaComponentsMap\",\n  \"typeNameFormatter\",\n  \"templatesWorker\",\n  \"codeFormatter\",\n  \"schemaParserFabric\",\n  \"schemaRoutes\",\n  \"javascriptTranslator\",\n];\n\nexport class CodeGenProcess {\n  config: CodeGenConfig;\n  swaggerSchemaResolver: SwaggerSchemaResolver;\n  schemaComponentsMap: SchemaComponentsMap;\n  typeNameFormatter: TypeNameFormatter;\n  schemaParserFabric: SchemaParserFabric;\n  schemaRoutes: SchemaRoutes;\n  fileSystem: FileSystem;\n  codeFormatter: CodeFormatter;\n  templatesWorker: TemplatesWorker;\n  schemaWalker: SchemaWalker;\n  javascriptTranslator: JavascriptTranslator;\n\n  constructor(config: Partial<GenerateApiConfiguration[\"config\"]>) {\n    this.config = new CodeGenConfig(config);\n    this.fileSystem = new FileSystem();\n    this.swaggerSchemaResolver = new SwaggerSchemaResolver(\n      this.config,\n      this.fileSystem,\n    );\n    this.schemaWalker = new SchemaWalker(\n      this.config,\n      this.swaggerSchemaResolver,\n    );\n    this.schemaComponentsMap = new SchemaComponentsMap(this.config);\n    this.typeNameFormatter = new TypeNameFormatter(this.config);\n    this.templatesWorker = new TemplatesWorker(\n      this.config,\n      this.fileSystem,\n      this.getRenderTemplateData,\n    );\n    this.codeFormatter = new CodeFormatter(this.config);\n    this.schemaParserFabric = new SchemaParserFabric(\n      this.config,\n      this.templatesWorker,\n      this.schemaComponentsMap,\n      this.typeNameFormatter,\n      this.schemaWalker,\n    );\n    this.schemaRoutes = new SchemaRoutes(\n      this.config,\n      this.schemaParserFabric,\n      this.schemaComponentsMap,\n      this.templatesWorker,\n      this.typeNameFormatter,\n    );\n    this.javascriptTranslator = new JavascriptTranslator(\n      this.config,\n      this.codeFormatter,\n    );\n  }\n\n  async start() {\n    this.config.update({\n      templatePaths: this.templatesWorker.getTemplatePaths(this.config),\n    });\n    this.config.update({\n      templatesToRender: this.templatesWorker.getTemplates(this.config),\n    });\n\n    const swagger = await this.swaggerSchemaResolver.create();\n\n    this.swaggerSchemaResolver.fixSwaggerSchema(swagger);\n\n    this.config.update({\n      swaggerSchema: swagger.usageSchema,\n      originalSchema: swagger.originalSchema,\n    });\n\n    this.schemaWalker.addSchema(\"$usage\", swagger.usageSchema);\n    this.schemaWalker.addSchema(\"$original\", swagger.originalSchema);\n\n    consola.info(\"start generating your typescript api\");\n\n    this.config.update(\n      this.config.hooks.onInit(this.config, this) || this.config,\n    );\n\n    this.schemaComponentsMap.clear();\n\n    lodash.each(swagger.usageSchema.components, (component, componentName) =>\n      lodash.each(component, (rawTypeData, typeName) => {\n        this.schemaComponentsMap.createComponent(\n          this.schemaComponentsMap.createRef([\n            \"components\",\n            componentName,\n            typeName,\n          ]),\n          rawTypeData,\n        );\n      }),\n    );\n\n    this.schemaComponentsMap.enumsFirst();\n\n    const componentsToParse: SchemaComponent[] =\n      this.schemaComponentsMap.filter(\n        lodash.compact([\n          \"schemas\",\n          this.config.extractResponses && \"responses\",\n        ]),\n      );\n\n    const parsedSchemas = componentsToParse.map((schemaComponent) => {\n      const parsed = this.schemaParserFabric.parseSchema(\n        schemaComponent.rawTypeData,\n        schemaComponent.typeName,\n      );\n      schemaComponent.typeData = parsed;\n      return parsed;\n    });\n\n    this.schemaRoutes.attachSchema({\n      usageSchema: swagger.usageSchema,\n      parsedSchemas,\n    });\n\n    const rawConfiguration = {\n      apiConfig: this.createApiConfig(swagger.usageSchema),\n      config: this.config,\n      modelTypes: this.collectModelTypes(),\n      hasSecurityRoutes: this.schemaRoutes.hasSecurityRoutes,\n      hasQueryRoutes: this.schemaRoutes.hasQueryRoutes,\n      hasFormDataRoutes: this.schemaRoutes.hasFormDataRoutes,\n      generateResponses: this.config.generateResponses,\n      routes: this.schemaRoutes.getGroupedRoutes(),\n      extraTemplates: this.config.extraTemplates,\n      fileName: this.config.fileName,\n      translateToJavaScript: this.config.toJS,\n      customTranslator: this.config.customTranslator\n        ? new this.config.customTranslator()\n        : null,\n      utils: this.getRenderTemplateData().utils,\n    };\n\n    const configuration =\n      this.config.hooks.onPrepareConfig(rawConfiguration) || rawConfiguration;\n\n    if (this.fileSystem.pathIsExist(this.config.output)) {\n      if (this.config.cleanOutput) {\n        consola.debug(\"cleaning dir\", this.config.output);\n        this.fileSystem.cleanDir(this.config.output);\n      }\n    } else {\n      consola.debug(\n        `path ${this.config.output} is not exist. creating dir by this path`,\n      );\n      this.fileSystem.createDir(this.config.output);\n    }\n\n    const files = await this.generateOutputFiles({\n      configuration: configuration,\n    });\n\n    const isDirPath = this.fileSystem.pathIsDir(this.config.output);\n\n    if (isDirPath) {\n      for (const file of files) {\n        this.fileSystem.createFile({\n          path: this.config.output,\n          fileName: `${file.fileName}${file.fileExtension}`,\n          content: file.fileContent,\n          withPrefix: true,\n        });\n\n        consola.success(\n          \"api file\",\n          `\"${file.fileName}${file.fileExtension}\"`,\n          `created in ${this.config.output}`,\n        );\n      }\n    }\n\n    return {\n      files,\n      configuration,\n      getTemplate: this.templatesWorker.getTemplate,\n      renderTemplate: this.templatesWorker.renderTemplate,\n      createFile: this.fileSystem.createFile,\n      formatTSContent: this.codeFormatter.formatCode,\n    };\n  }\n\n  getRenderTemplateData = () => {\n    return {\n      utils: {\n        Ts: this.config.Ts,\n        formatDescription:\n          this.schemaParserFabric.schemaFormatters.formatDescription,\n        internalCase: internalCase,\n        classNameCase: pascalCase,\n        pascalCase: pascalCase,\n        getInlineParseContent: this.schemaParserFabric.getInlineParseContent,\n        getParseContent: this.schemaParserFabric.getParseContent,\n        getComponentByRef: this.schemaComponentsMap.get,\n        parseSchema: this.schemaParserFabric.parseSchema,\n        checkAndAddNull: this.schemaParserFabric.schemaUtils.safeAddNullToType,\n        safeAddNullToType:\n          this.schemaParserFabric.schemaUtils.safeAddNullToType,\n        isNeedToAddNull:\n          this.schemaParserFabric.schemaUtils.isNullMissingInType,\n        inlineExtraFormatters: this.schemaParserFabric.schemaFormatters.inline,\n        formatters: this.schemaParserFabric.schemaFormatters.base,\n        formatModelName: this.typeNameFormatter.format,\n        fmtToJSDocLine: (line: string, { eol = true }) => {\n          return ` * ${line}${eol ? \"\\n\" : \"\"}`;\n        },\n        NameResolver: NameResolver,\n        _: lodash,\n        require: this.templatesWorker.requireFnFromTemplate,\n      },\n      config: this.config,\n    };\n  };\n\n  collectModelTypes = () => {\n    const components = this.schemaComponentsMap.getComponents();\n    let modelTypes = [];\n\n    const modelTypeComponents = lodash.compact([\n      \"schemas\",\n      this.config.extractResponses && \"responses\",\n    ]);\n\n    const getSchemaComponentsCount = () =>\n      this.schemaComponentsMap.filter(...modelTypeComponents).length;\n\n    let schemaComponentsCount = getSchemaComponentsCount();\n    let processedCount = 0;\n\n    while (processedCount < schemaComponentsCount) {\n      modelTypes = [];\n      processedCount = 0;\n      for (const component of components) {\n        if (modelTypeComponents.includes(component.componentName)) {\n          const modelType = this.prepareModelType(component);\n          if (modelType) {\n            modelTypes.push(modelType);\n          }\n          processedCount++;\n        }\n      }\n      schemaComponentsCount = getSchemaComponentsCount();\n    }\n\n    if (this.config.sortTypes) {\n      return modelTypes.sort(sortByProperty(\"name\"));\n    }\n\n    return modelTypes;\n  };\n\n  prepareModelType = (typeInfo) => {\n    if (typeInfo.$prepared) return typeInfo.$prepared;\n\n    if (!typeInfo.typeData) {\n      typeInfo.typeData = this.schemaParserFabric.parseSchema(\n        typeInfo.rawTypeData,\n        typeInfo.typeName,\n      );\n    }\n    const rawTypeData = typeInfo.typeData;\n    const typeData = this.schemaParserFabric.schemaFormatters.base[\n      rawTypeData.type\n    ]\n      ? this.schemaParserFabric.schemaFormatters.base[rawTypeData.type](\n          rawTypeData,\n        )\n      : rawTypeData;\n    const {\n      typeIdentifier,\n      name: originalName,\n      content,\n      description,\n    } = typeData;\n    const name = this.typeNameFormatter.format(originalName);\n\n    if (name === null) return null;\n\n    const preparedModelType = {\n      ...typeData,\n      typeIdentifier,\n      name,\n      description,\n      $content: rawTypeData.content,\n      rawContent: rawTypeData.content,\n      content: content,\n      typeData,\n    };\n\n    typeInfo.$prepared = preparedModelType;\n\n    return preparedModelType;\n  };\n\n  generateOutputFiles = async ({ configuration }): Promise<TranslatorIO[]> => {\n    const { modular, templatesToRender } = this.config;\n\n    const output = modular\n      ? await this.createMultipleFileInfos(templatesToRender, configuration)\n      : await this.createSingleFileInfo(templatesToRender, configuration);\n\n    if (!lodash.isEmpty(configuration.extraTemplates)) {\n      for (const extraTemplate of configuration.extraTemplates) {\n        const content = this.templatesWorker.renderTemplate(\n          this.fileSystem.getFileContent(extraTemplate.path),\n          configuration,\n        );\n        output.push(\n          ...(await this.createOutputFileInfo(\n            configuration,\n            extraTemplate.name,\n            content,\n          )),\n        );\n      }\n    }\n\n    return output.filter((fileInfo) => !!fileInfo && !!fileInfo.fileContent);\n  };\n\n  createMultipleFileInfos = async (\n    templatesToRender,\n    configuration,\n  ): Promise<TranslatorIO[]> => {\n    const { routes } = configuration;\n    const { fileNames, generateRouteTypes, generateClient } =\n      configuration.config;\n    const modularApiFileInfos: TranslatorIO[] = [];\n\n    if (routes.$outOfModule) {\n      if (generateRouteTypes) {\n        const outOfModuleRouteContent = this.templatesWorker.renderTemplate(\n          templatesToRender.routeTypes,\n          {\n            ...configuration,\n            route: configuration.routes.$outOfModule,\n          },\n        );\n\n        modularApiFileInfos.push(\n          ...(await this.createOutputFileInfo(\n            configuration,\n            fileNames.outOfModuleApi,\n            outOfModuleRouteContent,\n          )),\n        );\n      }\n      if (generateClient) {\n        const outOfModuleApiContent = this.templatesWorker.renderTemplate(\n          templatesToRender.api,\n          {\n            ...configuration,\n            route: configuration.routes.$outOfModule,\n          },\n        );\n\n        modularApiFileInfos.push(\n          ...(await this.createOutputFileInfo(\n            configuration,\n            fileNames.outOfModuleApi,\n            outOfModuleApiContent,\n          )),\n        );\n      }\n    }\n\n    if (routes.combined) {\n      for (const route of routes.combined) {\n        if (generateRouteTypes) {\n          const routeModuleContent = this.templatesWorker.renderTemplate(\n            templatesToRender.routeTypes,\n            {\n              ...configuration,\n              route,\n            },\n          );\n\n          modularApiFileInfos.push(\n            ...(await this.createOutputFileInfo(\n              configuration,\n              pascalCase(`${route.moduleName}_Route`),\n              routeModuleContent,\n            )),\n          );\n        }\n\n        if (generateClient) {\n          const apiModuleContent = this.templatesWorker.renderTemplate(\n            templatesToRender.api,\n            {\n              ...configuration,\n              route,\n            },\n          );\n\n          modularApiFileInfos.push(\n            ...(await this.createOutputFileInfo(\n              configuration,\n              pascalCase(route.moduleName),\n              apiModuleContent,\n            )),\n          );\n        }\n      }\n    }\n\n    return [\n      ...(await this.createOutputFileInfo(\n        configuration,\n        fileNames.dataContracts,\n        this.templatesWorker.renderTemplate(\n          templatesToRender.dataContracts,\n          configuration,\n        ),\n      )),\n      ...(generateClient\n        ? await this.createOutputFileInfo(\n            configuration,\n            fileNames.httpClient,\n            this.templatesWorker.renderTemplate(\n              templatesToRender.httpClient,\n              configuration,\n            ),\n          )\n        : []),\n      ...modularApiFileInfos,\n    ];\n  };\n\n  createSingleFileInfo = async (\n    templatesToRender,\n    configuration,\n  ): Promise<TranslatorIO[]> => {\n    const { generateRouteTypes, generateClient } = configuration.config;\n\n    return await this.createOutputFileInfo(\n      configuration,\n      configuration.fileName,\n      lodash\n        .compact([\n          this.templatesWorker.renderTemplate(\n            templatesToRender.dataContracts,\n            configuration,\n          ),\n          generateRouteTypes &&\n            this.templatesWorker.renderTemplate(\n              templatesToRender.routeTypes,\n              configuration,\n            ),\n          generateClient &&\n            this.templatesWorker.renderTemplate(\n              templatesToRender.httpClient,\n              configuration,\n            ),\n          generateClient &&\n            this.templatesWorker.renderTemplate(\n              templatesToRender.api,\n              configuration,\n            ),\n        ])\n        .join(\"\\n\"),\n    );\n  };\n\n  createOutputFileInfo = async (\n    configuration,\n    fileNameFull,\n    content,\n  ): Promise<TranslatorIO[]> => {\n    const fileName = this.fileSystem.cropExtension(fileNameFull);\n    const fileExtension = typescript.Extension.Ts;\n\n    if (configuration.translateToJavaScript) {\n      consola.debug(\"using js translator for\", fileName);\n      return await this.javascriptTranslator.translate({\n        fileName: fileName,\n        fileExtension: fileExtension,\n        fileContent: content,\n      });\n    }\n\n    if (configuration.customTranslator) {\n      consola.debug(\"using custom translator for\", fileName);\n      return await configuration.customTranslator.translate({\n        fileName: fileName,\n        fileExtension: fileExtension,\n        fileContent: content,\n      });\n    }\n\n    consola.debug(\"generating output for\", `${fileName}${fileExtension}`);\n\n    return [\n      {\n        fileName,\n        fileExtension: fileExtension,\n        fileContent: await this.codeFormatter.formatCode(content),\n      },\n    ];\n  };\n\n  createApiConfig = (swaggerSchema) => {\n    const { info, servers, host, basePath, externalDocs, tags } = swaggerSchema;\n    const server = servers?.[0] || { url: \"\" };\n    const { title = \"No title\", version } = info || {};\n    const { url: serverUrl } = server;\n\n    return {\n      info: info || {},\n      servers: servers || [],\n      basePath,\n      host,\n      externalDocs: lodash.merge(\n        {\n          url: \"\",\n          description: \"\",\n        },\n        externalDocs,\n      ),\n      tags: lodash.compact(tags),\n      baseUrl: serverUrl,\n      title,\n      version,\n    };\n  };\n\n  injectClassInstance = (key, value) => {\n    this[key] = value;\n    for (const instanceKey of PATCHABLE_INSTANCES) {\n      if (instanceKey !== key && key in this[instanceKey]) {\n        this[instanceKey][key] = value;\n      }\n    }\n  };\n}\n","import type {\n  GenerateTemplatesParams,\n  HttpClientType,\n} from \"../../../types/index.js\";\nimport { HTTP_CLIENT, PROJECT_VERSION } from \"../../constants.js\";\nimport { objectAssign } from \"../../util/object-assign.js\";\n\nexport class TemplatesGenConfig {\n  cleanOutput = false;\n  debug = false;\n  httpClientType: HttpClientType = HTTP_CLIENT.FETCH;\n  modular = false;\n  output = undefined;\n  rewrite = false;\n  silent = false;\n  version = PROJECT_VERSION;\n\n  constructor(config: GenerateTemplatesParams) {\n    this.update(config);\n  }\n\n  update = (update: Partial<GenerateTemplatesParams>) => {\n    objectAssign(this, update);\n  };\n}\n","import path from \"node:path\";\nimport url from \"node:url\";\nimport { consola } from \"consola\";\nimport type {\n  GenerateTemplatesOutput,\n  GenerateTemplatesParams,\n} from \"../../../types/index.js\";\nimport { FileSystem } from \"../../util/file-system.js\";\nimport { TemplatesGenConfig } from \"./configuration.js\";\n\nconst __dirname = path.dirname(url.fileURLToPath(import.meta.url));\n\nexport class TemplatesGenProcess {\n  config: TemplatesGenConfig;\n  fileSystem: FileSystem;\n\n  rootDir = path.resolve(__dirname, \"..\");\n\n  paths = {\n    baseTemplates: \"templates/base\",\n    httpClientTemplates: \"templates/base/http-clients\",\n    moduleApiTemplates: \"templates/modular\",\n    defaultApiTemplates: \"templates/default\",\n  };\n\n  importTemplatePrefixes = [\"@base\", \"@modular\", \"@default\"];\n\n  constructor(config: GenerateTemplatesParams) {\n    this.config = new TemplatesGenConfig(config);\n    this.fileSystem = new FileSystem();\n  }\n\n  async start(): Promise<GenerateTemplatesOutput> {\n    consola.info('start generating source templates \".ejs\" for code generator');\n\n    const templates = this.getTemplates();\n\n    if (this.config.output) {\n      consola.info(\"preparing output directory for source templates\");\n      const outputPath = path.resolve(process.cwd(), this.config.output);\n\n      if (this.fileSystem.pathIsExist(outputPath)) {\n        if (this.config.cleanOutput) {\n          this.fileSystem.cleanDir(outputPath);\n        }\n      } else {\n        this.fileSystem.createDir(outputPath);\n      }\n\n      for (const template of templates) {\n        const templateName = this.fileSystem.cropExtension(template.name);\n        const templateEjsPath = path.resolve(outputPath, `${templateName}.ejs`);\n        const templateEtaPath = path.resolve(outputPath, `${templateName}.eta`);\n        const templateEjsPathExist =\n          this.fileSystem.pathIsExist(templateEjsPath);\n        const templateEtaPathExist =\n          this.fileSystem.pathIsExist(templateEtaPath);\n\n        const templateNotExist = !templateEjsPathExist && !templateEtaPathExist;\n\n        if (templateNotExist) {\n          this.fileSystem.createFile({\n            path: outputPath,\n            fileName: template.name,\n            content: template.content,\n            withPrefix: false,\n          });\n        } else if (this.config.rewrite) {\n          if (templateEjsPathExist) {\n            this.fileSystem.createFile({\n              path: outputPath,\n              fileName: `${templateName}.ejs`,\n              content: template.content,\n              withPrefix: false,\n            });\n          } else if (templateEtaPathExist) {\n            this.fileSystem.createFile({\n              path: outputPath,\n              fileName: `${templateName}.eta`,\n              content: template.content,\n              withPrefix: false,\n            });\n          }\n        }\n      }\n\n      consola.success(\n        `source templates has been successfully created in \"${outputPath}\"`,\n      );\n    }\n\n    return {\n      files: templates,\n      configuration: this.config,\n      createFile: this.fileSystem.createFile,\n    };\n  }\n\n  getTemplates = () => {\n    const outputFiles = [];\n    const baseTemplates = this.getTemplateNamesFromDir(\n      this.paths.baseTemplates,\n    );\n    const httpClientTemplates = this.getTemplateNamesFromDir(\n      this.paths.httpClientTemplates,\n    );\n    const apiTemplatesPath = this.config.modular\n      ? this.paths.moduleApiTemplates\n      : this.paths.defaultApiTemplates;\n    const apiTemplates = this.getTemplateNamesFromDir(apiTemplatesPath);\n\n    const usingHttpClientTemplate = httpClientTemplates.find((template) =>\n      template.startsWith(`${this.config.httpClientType}-`),\n    );\n\n    let httpClientTemplateContent = \"\";\n\n    if (usingHttpClientTemplate) {\n      httpClientTemplateContent = this.fixTemplateContent(\n        this.getTemplateContent(\n          `${this.paths.httpClientTemplates}/${usingHttpClientTemplate}`,\n        ),\n      );\n    }\n\n    for (const fileName of baseTemplates) {\n      const templateContent =\n        (fileName === \"http-client.ejs\" && httpClientTemplateContent) ||\n        this.fixTemplateContent(\n          this.getTemplateContent(`${this.paths.baseTemplates}/${fileName}`),\n        );\n\n      outputFiles.push({\n        name: fileName,\n        content: templateContent,\n      });\n    }\n\n    for (const fileName of apiTemplates) {\n      outputFiles.push({\n        name: fileName,\n        content: this.fixTemplateContent(\n          this.getTemplateContent(`${apiTemplatesPath}/${fileName}`),\n        ),\n      });\n    }\n\n    return outputFiles;\n  };\n\n  fixTemplateContent = (content) => {\n    // includeFile(\"@base/\n    const importsRegExp1 = new RegExp(\n      `includeFile\\\\(\"(${this.importTemplatePrefixes\n        .map((v) => `(${v})`)\n        .join(\"|\")})/`,\n      \"g\",\n    );\n    // includeFile(`@base/\n    const importsRegExp2 = new RegExp(\n      `includeFile\\\\(\\`(${this.importTemplatePrefixes\n        .map((v) => `(${v})`)\n        .join(\"|\")})/`,\n      \"g\",\n    );\n    // includeFile('@base/\n    const importsRegExp3 = new RegExp(\n      `includeFile\\\\('(${this.importTemplatePrefixes\n        .map((v) => `(${v})`)\n        .join(\"|\")})/`,\n      \"g\",\n    );\n\n    return content\n      .replace(importsRegExp1, 'includeFile(\"./')\n      .replace(importsRegExp2, \"includeFile(`./\")\n      .replace(importsRegExp3, \"includeFile('./\");\n  };\n\n  getTemplateNamesFromDir = (dir) => {\n    return this.fileSystem\n      .readDir(path.resolve(this.rootDir, dir))\n      .filter((file) => file.endsWith(\".ejs\"));\n  };\n\n  getTemplateContent = (pathToFile) => {\n    return this.fileSystem.getFileContent(\n      path.resolve(this.rootDir, pathToFile),\n    );\n  };\n}\n","import { consola } from \"consola\";\nimport type { GenerateTemplatesParams } from \"../../../types/index.js\";\nimport { TemplatesGenProcess } from \"./templates-gen-process.js\";\n\nexport async function generateTemplates(config: GenerateTemplatesParams) {\n  if (config.debug) consola.level = Number.MAX_SAFE_INTEGER;\n  if (config.silent) consola.level = 0;\n  const codeGenProcess = new TemplatesGenProcess(config);\n  return await codeGenProcess.start();\n}\n","import { consola } from \"consola\";\nimport type { GenerateApiConfiguration } from \"../types/index.js\";\nimport { CodeGenProcess } from \"./code-gen-process.js\";\n\nexport async function generateApi(\n  config: Partial<GenerateApiConfiguration[\"config\"]>,\n) {\n  if (config.debug) consola.level = Number.MAX_SAFE_INTEGER;\n  if (config.silent) consola.level = 0;\n  const codeGenProcess = new CodeGenProcess(config);\n  return await codeGenProcess.start();\n}\n\nexport { generateTemplates } from \"./commands/generate-templates/index.js\";\nexport * as constants from \"./constants.js\";\n"],"mappings":"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"}